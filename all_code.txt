
----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\hooks\useLineQueries.js -----

import { useQuery } from "@tanstack/react-query";
import { timelineApi } from "@/features/timeline/api/timelineApi";

// ① 라인 목록 (언제나 요청)
export const useLines = () =>
  useQuery({
    queryKey: ["lines"], // 캐시 키
    queryFn: timelineApi.fetchLines,
    staleTime: 1000 * 60 * 30, // 30분 → fresh 판정
  });

// ② SDWT 목록 (lineId 가 있어야 동작)
export const useSDWT = (lineId) =>
  useQuery({
    queryKey: ["sdwts", lineId],
    queryFn: () => timelineApi.fetchSDWT(lineId),
    enabled: !!lineId, // ← false면 요청 자체를 안 보냄
    staleTime: 1000 * 60 * 30,
  });

// ③ EQP 목록 (line + sdwt 모두 골랐을 때만)
export const useEquipments = (lineId, sdwtId) =>
  useQuery({
    queryKey: ["equipments", lineId, sdwtId],
    queryFn: () => timelineApi.fetchEquipments(lineId, sdwtId),
    enabled: !!lineId && !!sdwtId,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\EqpSelector.jsx -----

import React from "react";
import { useEquipments } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * EQP 드롭다운
 */
export default function EqpSelector({ lineId, sdwtId, eqpId, setEqpId }) {
  // ① 데이터·상태 가져오기
  const { data: eqps = [], isLoading } = useEquipments(lineId, sdwtId);

  // ② Line 안 고르면 회색 disabled 박스
  if (!lineId)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-sm text-slate-500"
      >
        <option>EQP 선택…</option>
      </select>
    );

  // ③ fetch 중이면 스피너
  if (isLoading) return <LoadingSpinner />;

  // ④ 정상 렌더
  return (
    <select
      value={eqpId}
      onChange={(e) => setEqpId(e.target.value)} // 상태 lift-up
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-sm dark:text-slate-100 focus:ring-2 focus:ring-indigo-500"
      disabled={eqps.length === 0}
    >
      <option value="">EQP 선택…</option>
      {eqps.map((e) => (
        <option key={e.id} value={e.id}>
          {e.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\index.js -----

export { default as LineSelector } from "./LineSelector";
export { default as SDWTSelector } from "./SDWTSelector";
export { default as EqpSelector } from "./EqpSelector";


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\LineSelector.jsx -----

import React from "react";
import { useLines } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * 라인 목록 드롭다운
 */
export default function LineSelector({ lineId, setLineId }) {
  const { data: lines = [], isLoading } = useLines();

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={lineId}
      onChange={(e) => setLineId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-sm dark:text-slate-100 focus:ring-2 focus:ring-indigo-500"
    >
      <option value="">라인 선택…</option>
      {lines.map((l) => (
        <option key={l.id} value={l.id}>
          {l.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\SDWTSelector.jsx -----

import React from "react";
import { useSDWT } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * SDWT 드롭다운
 */
export default function SDWTSelector({ lineId, sdwtId, setSdwtId }) {
  const { data: sdwts = [], isLoading } = useSDWT(lineId);

  if (!lineId)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-sm text-slate-500"
      >
        <option>SDWT 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={sdwtId}
      onChange={(e) => setSdwtId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-sm dark:text-slate-100 focus:ring-2 focus:ring-indigo-500"
    >
      <option value="">SDWT 선택…</option>
      {sdwts.map((s) => (
        <option key={s.id} value={s.id}>
          {s.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\table\CombinedDataTable.jsx -----

import React, { useEffect, useRef } from "react";
import { useSelectionStore } from "@/shared/store";

/**
 * 날짜 형식 변환 함수
 * 예: "2025. 6. 2. 10시 0분 0초" → "25/06/02 10:00"
 */
function formatDateString(dateString) {
  const match = dateString.match(
    /(\d{4})\. (\d{1,2})\. (\d{1,2})\. (\d{1,2})시 (\d{1,2})분/
  );
  if (!match) return dateString;

  const [, year, month, day, hour, minute] = match;
  return `${year.slice(2)}/${month.padStart(2, "0")}/${day.padStart(
    2,
    "0"
  )} ${hour.padStart(2, "0")}:${minute.padStart(2, "0")}`;
}

/**
 * 통합 데이터 테이블 컴포넌트
 * @param {Object[]} data - 필터링된 로그 배열
 * @param {Object} typeFilters - 로그 타입 필터링 상태
 * @param {Function} handleFilter - 체크박스 변경 핸들러
 */
export default function CombinedDataTable({ data, typeFilters, handleFilter }) {
  const { selectedRow, source, setSelectedRow } = useSelectionStore();
  const rowRefs = useRef({});

  useEffect(() => {
    if (source === "timeline" && selectedRow && rowRefs.current[selectedRow]) {
      rowRefs.current[selectedRow].scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    }
  }, [selectedRow, source]);

  const cols = [
    { header: "시간", accessor: "displayTimestamp" },
    { header: "타입", accessor: "logType" },
    { header: "정보 1", accessor: "info1" },
    { header: "정보 2", accessor: "info2" },
    { header: "지속(초)", accessor: "duration" },
  ];

  return (
    <div className="h-full flex flex-col overflow-hidden">
      {/* 상단 필터 영역 */}
      <div className="flex justify-between items-center p-4 pt-2 bg-white dark:bg-slate-800 text-gray-900 dark:text-white rounded-t-lg">
        <h3 className="text-lg font-semibold">통합 데이터 로그</h3>
        <div className="flex gap-3 flex-wrap">
          {Object.entries(typeFilters).map(([type, checked]) => (
            <label
              key={type}
              className="flex items-center gap-1 text-sm font-bold"
            >
              <input
                type="checkbox"
                name={type}
                checked={checked}
                onChange={handleFilter}
                className="rounded border-gray-300 dark:border-slate-600"
              />
              {type.replace("_LOG", "")}
            </label>
          ))}
        </div>
      </div>

      {/* 테이블 영역 */}
      {data.length === 0 ? (
        <div className="text-center text-sm text-gray-500 dark:text-gray-400 p-4">
          표시할 데이터가 없습니다.
        </div>
      ) : (
        <div className="flex-1 overflow-auto table-scroll">
          <table className="w-full text-sm text-center text-gray-800 dark:text-gray-200">
            <thead className="sticky top-0 bg-gray-200 text-gray-900 dark:bg-gray-600 dark:text-gray-100">
              <tr>
                {cols.map((c) => (
                  <th key={c.accessor} className="px-6 py-3 font-semibold">
                    {c.header}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {data.map((row) => {
                const isSel = String(row.id) === String(selectedRow);
                return (
                  <tr
                    key={row.id}
                    ref={(el) => (rowRefs.current[row.id] = el)}
                    onClick={() => setSelectedRow(row.id, "table")}
                    className={`transition-colors duration-300 cursor-pointer ${
                      isSel
                        ? "bg-yellow-100 dark:bg-yellow-800"
                        : "bg-white dark:bg-gray-800"
                    }`}
                  >
                    {cols.map((c) => (
                      <td key={c.accessor} className="px-1 py-3">
                        {c.accessor === "displayTimestamp"
                          ? formatDateString(row[c.accessor])
                          : row[c.accessor] ?? "-"}
                      </td>
                    ))}
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\api\timelineApi.js -----

import { apiClient } from "@/shared/apiClient";

export const timelineApi = {
  // “라인 목록” 엔드포인트
  fetchLines: () => apiClient("/lines"),
  // 필요 파라미터는 params 객체로
  fetchSDWT: (lineId) => apiClient("/sdwts", { params: { lineId } }),
  fetchEquipments: (l, s) =>
    apiClient("/equipments", { params: { lineId: l, sdwtId: s } }),
  fetchLogs: ({ lineId, sdwtId, eqpId }) =>
    apiClient("/logs", { params: { lineId, sdwtId, eqpId } }),
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\Legend.jsx -----

import React, { useRef, useState, useEffect } from "react";
import { groupConfig } from "@/features/timeline/utils/timelineMeta";

/**
 * 드래그 가능한 범례 컴포넌트
 * @param {string[]} logTypes
 */
export default function Legend({ logTypes }) {
  const legendRef = useRef(null);
  const [position, setPosition] = useState({ x: 100, y: 100 });
  const [dragging, setDragging] = useState(false);
  const offset = useRef({ x: 0, y: 0 });

  const onMouseDown = (e) => {
    // legend 기준 offset 계산
    const rect = legendRef.current.getBoundingClientRect();
    offset.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    };
    setDragging(true);
  };

  const onMouseMove = (e) => {
    if (!dragging) return;
    setPosition({
      x: e.clientX - offset.current.x,
      y: e.clientY - offset.current.y,
    });
  };

  const onMouseUp = () => setDragging(false);

  useEffect(() => {
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);
    return () => {
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    };
  }, [dragging]);

  return (
    <div
      ref={legendRef}
      onMouseDown={onMouseDown}
      className="bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 rounded-md shadow px-3 py-2 text-sm space-y-1 cursor-move fixed z-50"
      style={{
        top: `${position.y}px`,
        left: `${position.x}px`,
        userSelect: "none",
      }}
    >
      {logTypes.map((type) => {
        const config = groupConfig[type];
        if (!config) return null;
        return Object.entries(config.stateColors).map(([event, cls]) => (
          <div key={`${type}-${event}`} className="flex items-center gap-2">
            <span className={`w-4 h-4 inline-block rounded ${cls}`} />
            <span className="text-slate-800 dark:text-slate-100">
              {type.replace("_LOG", "")} - {event}
            </span>
          </div>
        ));
      })}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\NonStackedTimeline.jsx -----

import React, { useEffect, useRef } from "react";
import { DataSet } from "vis-data";
import { processData } from "@/features/timeline/utils/timelineUtils";
import { useSelectionStore } from "@/shared/store";
import Legend from "./Legend";

/**
 * EQP_LOG + TIP_LOG 를 stack 없이 나란히 보여주는 타임라인
 */
export default function NonStackedTimeline({ dataMap, range }) {
  const containerRef = useRef(null);
  const tlRef = useRef(null); // 인스턴스 보관

  // 전역 선택/동기화 스토어
  const { selectedRow, setSelectedRow, register, unregister, syncRange } =
    useSelectionStore();

  // 1️⃣ 생성 Effect – 의존성 []
  useEffect(() => {
    let mounted = true;
    (async () => {
      const { Timeline } = await import("vis-timeline/standalone");
      if (!mounted || !containerRef.current) return;

      /* 그룹 & 아이템 */
      const groups = [
        { id: "EQP", content: "EQP 상태", className: "custom-group-label" },
        { id: "TIP", content: "TIP 상태", className: "custom-group-label" },
      ];
      const items = new DataSet(
        groups.flatMap((g) => processData(g.id, dataMap[g.id] || []))
      );

      /* 인스턴스 생성 */
      tlRef.current = new Timeline(containerRef.current, items, groups, {
        stack: false,
        min: range.min,
        max: range.max,
        zoomMin: 60 * 1000,
        margin: { item: 0, axis: 0 },
        groupOrder: (a, b) =>
          ["EQP", "TIP"].indexOf(a.id) - ["EQP", "TIP"].indexOf(b.id),
        selectable: true,
      });

      register(tlRef.current);

      /* X축 동기화 */
      tlRef.current.on("rangechange", ({ start, end }) =>
        syncRange(tlRef.current, start, end)
      );

      /* 아이템 선택 → 전역 상태로 전파 */
      tlRef.current.on("select", ({ items }) =>
        setSelectedRow(items?.[0] ?? null, "timeline")
      );
    })();

    return () => {
      mounted = false;
      if (tlRef.current) {
        unregister(tlRef.current);
        tlRef.current.destroy();
      }
    };
  }, []); // 빈 배열

  /* 2️⃣ 데이터 바뀔 때 아이템만 교체 */
  useEffect(() => {
    if (tlRef.current) {
      const items = new DataSet(
        ["EQP", "TIP"].flatMap((id) => processData(id, dataMap[id] || []))
      );
      tlRef.current.setItems(items);
    }
  }, [dataMap]);

  /* 3️⃣ 선택 동기화 */
  useEffect(() => {
    if (tlRef.current) {
      if (selectedRow && tlRef.current.itemsData.get(selectedRow)) {
        tlRef.current.setSelection([selectedRow]);
      } else {
        tlRef.current.setSelection([]);
      }
    }
  }, [selectedRow]);

  return (
    <div className="timeline-container relative">
      <h3 className="text-sm font-semibold mb-1 text-slate-600 dark:text-slate-300">
        ⛓ EQP + TIP 로그
      </h3>
      <div ref={containerRef} className="timeline" />
      <Legend logTypes={["EQP", "TIP"]} />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\StackedTimeline.jsx -----

import React, { useEffect, useMemo, useRef } from "react";
import { DataSet } from "vis-data";
import {
  processData,
  calcRange,
  addBuffer,
} from "@/features/timeline/utils/timelineUtils";
import { useSelectionStore } from "@/shared/store";

/**
 * CTTTM_LOG + RACB_LOG 를 stack=true 로 보여주는 타임라인
 */
export default function StackedTimeline({ dataMap }) {
  const containerRef = useRef(null);
  const tlRef = useRef(null);

  const { selectedRow, setSelectedRow, register, unregister, syncRange } =
    useSelectionStore();

  /* 그룹 정의 */
  const groups = useMemo(
    () => [
      {
        id: "CTTTM",
        content: "CTTTM 이벤트",
        height: 100,
        className: "custom-group-label",
      },
      {
        id: "RACB",
        content: "RACB 이벤트",
        height: 150,
        className: "custom-group-label",
      },
    ],
    []
  );

  /* 전체 범위 */
  const range = useMemo(() => {
    const all = [...(dataMap.CTTTM || []), ...(dataMap.RACB || [])];
    const { min, max } = calcRange(all);
    return addBuffer(min.getTime(), max.getTime());
  }, [dataMap]);

  /* 1️⃣ 최초 mount 때만 인스턴스 생성 */
  useEffect(() => {
    let mounted = true;
    (async () => {
      const { Timeline } = await import("vis-timeline/standalone");
      if (!mounted || !containerRef.current) return;

      const items = new DataSet(
        groups.flatMap((g) => processData(g.id, dataMap[g.id] || []))
      );

      tlRef.current = new Timeline(containerRef.current, items, groups, {
        stack: true,
        min: range.min,
        max: range.max,
        zoomMin: 60 * 1000,
        verticalScroll: true,
        groupHeightMode: "fixed",
        groupOrder: (a, b) =>
          ["CTTTM", "RACB"].indexOf(a.id) - ["CTTTM", "RACB"].indexOf(b.id),
      });

      register(tlRef.current);
      tlRef.current.on("rangechange", ({ start, end }) =>
        syncRange(tlRef.current, start, end)
      );
      tlRef.current.on("select", ({ items }) =>
        setSelectedRow(items?.[0] ?? null, "timeline")
      );
    })();

    return () => {
      mounted = false;
      if (tlRef.current) {
        unregister(tlRef.current);
        tlRef.current.destroy();
      }
    };
  }, []); // ← 의존성 배열 **빈 배열** (once)

  /* 2️⃣ 데이터가 바뀌면 아이템만 교체 */
  useEffect(() => {
    if (tlRef.current) {
      const items = new DataSet(
        groups.flatMap((g) => processData(g.id, dataMap[g.id] || []))
      );
      tlRef.current.setItems(items);
    }
  }, [dataMap, groups]);

  /* 3️⃣ 외부(Table) 선택 반영 */
  useEffect(() => {
    if (tlRef.current) {
      if (selectedRow && tlRef.current.itemsData.get(selectedRow)) {
        tlRef.current.setSelection([selectedRow]);
      } else {
        tlRef.current.setSelection([]);
      }
    }
  }, [selectedRow]);

  return (
    <div className="timeline-container">
      <h3 className="text-sm font-semibold mb-1 text-slate-600 dark:text-slate-300">
        📍 CTTTM + RACB 로그
      </h3>
      <div
        ref={containerRef}
        className="timeline"
        style={{ height: "550px", overflow: "hidden" }}
      />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\TimelineBoard.jsx -----

import React, { useMemo } from "react";
import NonStackedTimeline from "./NonStackedTimeline";
import StackedTimeline from "./StackedTimeline";
import { calcRange, addBuffer } from "@/features/timeline/utils/timelineUtils";

export default function TimelineBoard({ dataMap }) {
  const eqpLogArr = dataMap.EQP || [];
  const tipLogArr = dataMap.TIP || [];
  const ctttmLogArr = dataMap.CTTTM || [];
  const racbLogArr = dataMap.RACB || [];

  const allLogs = useMemo(
    () => [...eqpLogArr, ...tipLogArr, ...ctttmLogArr, ...racbLogArr],
    [eqpLogArr, tipLogArr, ctttmLogArr, racbLogArr]
  );

  const fullRange = useMemo(() => {
    const r = calcRange(allLogs);
    return addBuffer(r.min.getTime(), r.max.getTime());
  }, [allLogs]);

  return (
    <div className="w-full space-y-4">
      <NonStackedTimeline
        dataMap={{ EQP: eqpLogArr, TIP: tipLogArr }}
        range={fullRange}
      />
      <StackedTimeline dataMap={{ CTTTM: ctttmLogArr, RACB: racbLogArr }} />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useLogQueries.js -----

import { useQuery } from "@tanstack/react-query";
import { timelineApi } from "@/features/timeline/api/timelineApi";

/** 전체 로그 한 번에 */
export const useLogs = ({ lineId, sdwtId, eqpId }, enabled) =>
  useQuery({
    queryKey: ["logs", lineId, sdwtId, eqpId],
    queryFn: () => timelineApi.fetchLogs({ lineId, sdwtId, eqpId }),
    enabled,
    staleTime: 1000 * 60 * 5,
  });


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useTimeline.js -----

import { useRef } from "react";
import { useTimelineRenderer } from "./useTimelineRenderer";

export const useTimeline = (groupKey, data, options) => {
  const ref = useRef(null);
  useTimelineRenderer(ref, groupKey, data, options);
  return ref;
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useTimelineRenderer.js -----

import { useEffect, useRef } from "react";
import { processData } from "@/features/timeline/utils/timelineUtils";
import { useSelectionStore } from "@/shared/store";
import { DataSet as VisDataSet } from "vis-data"; // ✅

export const useTimelineRenderer = (containerRef, groupKey, data, options) => {
  const tlRef = useRef(null);
  const { register, unregister, syncRange, setSelectedRow } =
    useSelectionStore();

  /* 1. 최초 생성 */
  useEffect(() => {
    if (!containerRef.current) return;

    let mounted = true;
    (async () => {
      const { Timeline } = await import(
        /* webpackChunkName: "vis-timeline" */ "vis-timeline/standalone"
      );
      if (!mounted) return;

      const items = new VisDataSet(processData(groupKey, data)); // ✅
      tlRef.current = new Timeline(containerRef.current, items, options);

      register(tlRef.current);

      tlRef.current.on("rangechange", ({ start, end }) =>
        syncRange(tlRef.current, start, end)
      );

      tlRef.current.on("select", (e) => {
        const id = e.items?.[0];
        if (id) setSelectedRow(id, "timeline");
      });
    })();

    return () => {
      mounted = false;
      if (tlRef.current) {
        unregister(tlRef.current);
        tlRef.current.destroy();
      }
    };
  }, [groupKey]);

  /* 2. 데이터 변경 시 아이템만 교체 */
  useEffect(() => {
    if (tlRef.current) {
      tlRef.current.setItems(new VisDataSet(processData(groupKey, data))); // ✅
    }
  }, [data]);

  return tlRef;
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\utils\timelineMeta.js -----

/**
 * 각 로그 타입(logType)별 컬러 매핑
 * Tailwind 색상 클래스로 작성 (timeline.css @apply 로 색 지정)
 */
export const groupConfig = {
  EQP: {
    stateColors: {
      RUN: "bg-blue-600 border-blue-700",
      IDLE: "bg-yellow-600 border-yellow-700",
      PM: "bg-green-600 border-green-700",
      DOWN: "bg-red-600 border-red-700",
    },
  },
  TIP: {
    stateColors: {
      OPEN: "bg-blue-600 border-blue-700",
      CLOSE: "bg-red-600 border-red-700",
    },
  },
  RACB: {
    stateColors: {
      ALARM: "bg-red-600 border-red-700",
      WARN: "bg-amber-600 border-amber-700",
    },
  },
  CTTTM: {
    stateColors: {
      TTM_FAIL: "bg-red-600 border-red-700",
      TTM_WARN: "bg-yellow-600 border-yellow-700",
    },
  },
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\utils\timelineUtils.js -----

import { groupConfig } from "./timelineMeta";

/** ➜ 로그 Item.id 생성 (예: RACB_LOG-2025-06-02T12:00:00.000Z) */
export const makeItemId = (group, time) => {
  const iso = new Date(time).toISOString().replace(/\.\d+Z$/, ".000Z");
  return `${group}-${iso}`;
};

/** ➜ vis-timeline 아이템 변환 */
export const processData = (logType, data) => {
  const cfg = groupConfig[logType];
  if (!cfg) return [];

  return data
    .filter((l) => l && l.eventTime)
    .map((l) => {
      const start = new Date(l.eventTime);
      const end = l.endTime ? new Date(l.endTime) : start;
      const isRange = !!l.endTime;
      const colorCls = cfg.stateColors[l.eventType] || "bg-gray-300";

      return {
        id: l.id,
        group: logType,
        content: l.comment || "",
        start,
        end,
        type: isRange ? "range" : "point",
        className: colorCls,
        title: [
          l.comment,
          l.operator ? `👤 ${l.operator}` : null,
          l.url ? `🔗 ${l.url}` : null,
        ]
          .filter(Boolean)
          .join("\n"),
      };
    });
};

/** ±3일 버퍼 */
export const addBuffer = (min, max) => {
  const B = 3 * 24 * 60 * 60 * 1000;
  return { min: new Date(min - B), max: new Date(max + B) };
};

/** 전체 로그 범위 계산 */
export const calcRange = (logs) => {
  const ts = logs
    .flatMap((l) => [
      new Date(l.eventTime).getTime(),
      l.endTime ? new Date(l.endTime).getTime() : undefined,
    ])
    .filter(Boolean);

  if (!ts.length) {
    const now = new Date();
    return { min: now, max: now };
  }
  return { min: new Date(Math.min(...ts)), max: new Date(Math.max(...ts)) };
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\index.js -----

export * from "./api/timelineApi";
export * from "./hooks/useLogQueries";
export { default as TimelineBoard } from "./components/TimelineBoard";


----- C:\Users\pjw75\Desktop\eqp-timeline\src\pages\TimelinePage.jsx -----

import React, { useState, useMemo } from "react";
import { useLogs } from "@/features/timeline";
import { LineSelector, SDWTSelector, EqpSelector } from "@/features/drilldown";
import { TimelineBoard } from "@/features/timeline";
import CombinedDataTable from "@/features/table/CombinedDataTable";
import LoadingSpinner from "@/shared/LoadingSpinner";
import { useSelectionStore } from "@/shared/store";

const DATA_TYPES = {
  EQP: "EQP",
  TIP: "TIP",
  RACB: "RACB",
  CTTTM: "CTTTM",
};

export default function TimelinePage() {
  /* ───────────────── 드릴다운 상태 (Zustand) ───────────────── */
  const { lineId, sdwtId, eqpId, setLine, setSdwt, setEqp } =
    useSelectionStore();

  /* ───────────────── 로그 Fetch ───────────────── */
  const enabled = Boolean(lineId && eqpId);
  const {
    data: logs = [],
    isLoading: logsLoading,
    isError: logsError,
  } = useLogs({ lineId, sdwtId, eqpId }, enabled);

  /* ───────────────── 체크박스 필터 ───────────────── */
  const [typeFilters, setTypeFilters] = useState({
    [DATA_TYPES.EQP]: true,
    [DATA_TYPES.TIP]: true,
    [DATA_TYPES.RACB]: true,
    [DATA_TYPES.CTTTM]: true,
  });
  const handleFilter = (e) =>
    setTypeFilters((p) => ({ ...p, [e.target.name]: e.target.checked }));

  /* ───────────────── 로그 분류 & 테이블 가공 ───────────────── */
  const logsByType = useMemo(() => {
    const g = { EQP: [], TIP: [], RACB: [], CTTTM: [] };
    logs.forEach((l) => g[l.logType]?.push(l));
    return g;
  }, [logs]);

  const tableData = useMemo(() => {
    if (!enabled || logsLoading) return [];
    return logs
      .map((l) => ({
        id: l.id,
        displayTimestamp: new Date(l.eventTime).toLocaleString("ko-KR", {
          hour12: false,
        }),
        logType: l.logType,
        info1: l.eventType,
        info2: l.operator || "-",
        duration: l.duration?.toFixed(0) ?? "-",
      }))
      .filter((r) => typeFilters[r.logType])
      .sort(
        (a, b) => new Date(b.displayTimestamp) - new Date(a.displayTimestamp)
      );
  }, [logs, logsLoading, enabled, typeFilters]);

  /* ───────────────── UI ───────────────── */
  if (logsError)
    return (
      <div className="flex items-center justify-center h-[80vh]">
        <p className="text-red-500">로그 로딩 오류!</p>
      </div>
    );

  return (
    <div className="flex flex-col lg:flex-row h-[calc(100vh-110px)] gap-3 mt-4">
      {/* 왼쪽: 선택기 + 테이블 */}
      <div className="lg:w-[40%] flex flex-col gap-4 h-full">
        <div className="p-4 bg-white dark:bg-slate-800 shadow rounded-xl">
          <h2 className="text-lg font-bold mb-3 text-slate-900 dark:text-white">
            📊 EQP 타임라인 뷰어
          </h2>

          {/* 드릴다운 */}
          <div className="grid grid-cols-3 gap-2 mb-2">
            <LineSelector lineId={lineId} setLineId={setLine} />
            <SDWTSelector lineId={lineId} sdwtId={sdwtId} setSdwtId={setSdwt} />
            <EqpSelector
              lineId={lineId}
              sdwtId={sdwtId}
              eqpId={eqpId}
              setEqpId={setEqp}
            />
          </div>
        </div>

        {/* 테이블 */}
        <div className="flex-1 overflow-auto bg-white dark:bg-slate-800 shadow rounded-xl p-3">
          {!eqpId && !logsLoading ? (
            <p className="text-center text-slate-600 dark:text-slate-400">
              EQP를 선택하세요.
            </p>
          ) : logsLoading ? (
            <div className="flex items-center justify-center h-full">
              <LoadingSpinner />
            </div>
          ) : (
            <CombinedDataTable
              data={tableData}
              typeFilters={typeFilters}
              handleFilter={handleFilter}
            />
          )}
        </div>
      </div>

      {/* 오른쪽: 타임라인 */}
      <div className="lg:w-[60%] h-full overflow-auto bg-white dark:bg-slate-800 shadow rounded-xl p-4">
        {!eqpId && !logsLoading ? (
          <p className="text-center text-slate-600 dark:text-slate-400 py-20">
            EQP 선택 후 타임라인을 확인하세요.
          </p>
        ) : logsLoading ? (
          <div className="flex items-center justify-center h-full">
            <LoadingSpinner />
          </div>
        ) : (
          <TimelineBoard dataMap={logsByType} />
        )}
      </div>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\apiClient.js -----

export const apiClient = async (url, { params, ...opts } = {}) => {
  // ① 쿼리스트링 만들어 붙이고
  const qs = params ? "?" + new URLSearchParams(params) : "";
  // ② fetch 실행 (기본 JSON 헤더 셋팅)
  const res = await fetch(import.meta.env.VITE_API_BASE_URL + url + qs, {
    headers: { "Content-Type": "application/json" },
    ...opts,
  });
  // ③ 에러 땐 throw → react-query가 캐치
  if (!res.ok) throw new Error((await res.text()) || `API ${res.status}`);
  // ④ 항상 JSON 반환
  return res.json();
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\LoadingSpinner.jsx -----

export default function LoadingSpinner() {
  return (
    <div className="flex justify-center items-center" role="status">
      <div className="animate-spin rounded-full h-5 w-5 border-4 border-blue-500 border-t-transparent" />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\Navbar.jsx -----

import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import {
  Dialog,
  DialogPanel,
  Disclosure,
  DisclosureButton,
  DisclosurePanel,
  Popover,
  PopoverButton,
  PopoverGroup,
  PopoverPanel,
} from "@headlessui/react";
import {
  ArrowPathIcon,
  Bars3Icon,
  ChartPieIcon,
  CursorArrowRaysIcon,
  FingerPrintIcon,
  SquaresPlusIcon,
  XMarkIcon,
  SunIcon,
  MoonIcon,
} from "@heroicons/react/24/outline";
import {
  ChevronDownIcon,
  PhoneIcon,
  PlayCircleIcon,
} from "@heroicons/react/20/solid";

// "Product" 드롭다운에 사용될 예시 데이터
const products = [
  {
    name: "Analytics",
    description: "트래픽 분석",
    href: "#",
    icon: ChartPieIcon,
  },
  {
    name: "Engagement",
    description: "고객 소통",
    href: "#",
    icon: CursorArrowRaysIcon,
  },
  {
    name: "Security",
    description: "데이터 보안",
    href: "#",
    icon: FingerPrintIcon,
  },
  {
    name: "Integrations",
    description: "외부 연동",
    href: "#",
    icon: SquaresPlusIcon,
  },
  {
    name: "Automations",
    description: "자동화",
    href: "#",
    icon: ArrowPathIcon,
  },
];
const callsToAction = [
  { name: "Watch demo", href: "#", icon: PlayCircleIcon },
  { name: "Contact sales", href: "#", icon: PhoneIcon },
];

export default function Navbar() {
  // 모바일 메뉴와 다크모드 상태를 관리
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [darkMode, setDarkMode] = useState(false);

  // 컴포넌트가 처음 마운트될 때, localStorage나 OS 기본 테마를 기준으로 다크모드 설정을 결정
  useEffect(() => {
    const isDark =
      localStorage.theme === "dark" ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches);
    setDarkMode(isDark);
    if (isDark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, []);

  // 다크모드 토글 (버튼 클릭 시 실행)
  const toggleDarkMode = () => {
    // Tailwind 공식 권장 방식: classList.toggle 로 결과값을 그대로 사용
    const isDark = document.documentElement.classList.toggle("dark");
    setDarkMode(isDark);

    // 사용자가 '라이트' 모드를 선택한 경우 key 자체를 지워 두면
    // 다음 방문 시 OS 선호도(prefers-color-scheme)가 다시 적용됩니다.
    if (isDark) {
      localStorage.theme = "dark";
    } else {
      localStorage.removeItem("theme");
    }
  };

  return (
    // 상단 고정 네비게이션 바
    <header className="bg-gray-100 dark:bg-gray-800 shadow-md sticky top-0 z-50  h-20">
      <nav
        aria-label="Global"
        className="mx-auto flex max-w-7xl items-center justify-between p-5 lg:px-8"
      >
        {/* 로고: 메인 페이지로 이동 */}
        <div className="flex lg:flex-1">
          <Link to="/" className="-m-1.5 p-1.5">
            <span className="sr-only">Your Company</span>
            <img
              alt="Company Logo"
              src="https://tailwindcss.com/plus-assets/img/logos/158x48/transistor-logo-gray-900.svg"
              className="h-8 w-auto"
            />
          </Link>
        </div>
        {/* 모바일 메뉴 버튼 (작은 화면에서만 보임) */}
        <div className="flex lg:hidden">
          <button
            type="button"
            onClick={() => setMobileMenuOpen(true)}
            className="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700 dark:text-gray-300"
          >
            <span className="sr-only">Open main menu</span>
            <Bars3Icon aria-hidden="true" className="size-6" />
          </button>
        </div>
        {/* 데스크탑 메뉴: Product, Timeline 등 네비게이션 */}
        <PopoverGroup className="hidden lg:flex lg:gap-x-12">
          <Popover className="relative">
            <PopoverButton className="flex items-center gap-x-1 text-sm/6 font-semibold text-gray-900 dark:text-gray-100 focus:outline-none">
              Product
              <ChevronDownIcon
                aria-hidden="true"
                className="size-5 flex-none text-gray-400 dark:text-gray-500"
              />
            </PopoverButton>
            {/* Product 드롭다운 패널 */}
            <PopoverPanel
              transition
              className="absolute top-full -left-8 z-20 mt-3 w-screen max-w-md overflow-hidden rounded-3xl bg-white dark:bg-gray-800 shadow-lg ring-1 ring-gray-900/5 dark:ring-white/10 transition"
            >
              <div className="p-4">
                {products.map((item) => (
                  <div
                    key={item.name}
                    className="group relative flex items-center gap-x-6 rounded-lg p-4 text-sm/6 hover:bg-gray-50 dark:hover:bg-gray-700"
                  >
                    <div className="flex size-11 flex-none items-center justify-center rounded-lg bg-gray-50 dark:bg-gray-700 group-hover:bg-white dark:group-hover:bg-gray-600">
                      <item.icon
                        aria-hidden="true"
                        className="size-6 text-gray-600 dark:text-gray-400 group-hover:text-indigo-600 dark:group-hover:text-indigo-400"
                      />
                    </div>
                    <div className="flex-auto">
                      <a
                        href={item.href}
                        className="block font-semibold text-gray-900 dark:text-gray-100"
                      >
                        {item.name}
                        <span className="absolute inset-0" />
                      </a>
                      <p className="mt-1 text-gray-600 dark:text-gray-400">
                        {item.description}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
              {/* 하단 액션 버튼 */}
              <div className="grid grid-cols-2 divide-x divide-gray-900/5 dark:divide-white/10 bg-gray-50 dark:bg-gray-700/50">
                {callsToAction.map((item) => (
                  <a
                    key={item.name}
                    href={item.href}
                    className="flex items-center justify-center gap-x-2.5 p-3 text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-600"
                  >
                    <item.icon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500"
                    />
                    {item.name}
                  </a>
                ))}
              </div>
            </PopoverPanel>
          </Popover>
          {/* 타임라인 페이지로 이동하는 메뉴 */}
          <Link
            to="/timeline"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Timeline
          </Link>
          <a
            href="#"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Marketplace
          </a>
          <a
            href="#"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Company
          </a>
        </PopoverGroup>
        {/* 데스크탑: 다크모드 토글 + 로그인 */}
        <div className="hidden lg:flex lg:flex-1 lg:items-center lg:justify-end lg:gap-x-6">
          <button
            onClick={toggleDarkMode}
            className="p-2 rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none"
            aria-label="Toggle dark mode"
          >
            {darkMode ? (
              <SunIcon className="size-6" />
            ) : (
              <MoonIcon className="size-6" />
            )}
          </button>
          <a
            href="#"
            className="text-sm/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Log in <span aria-hidden="true">&rarr;</span>
          </a>
        </div>
      </nav>
      {/* 모바일 메뉴 다이얼로그: 작은 화면에서만 열림 */}
      <Dialog
        open={mobileMenuOpen}
        onClose={setMobileMenuOpen}
        className="lg:hidden"
      >
        <div className="fixed inset-0 z-20" />
        <DialogPanel className="fixed inset-y-0 right-0 z-30 w-full overflow-y-auto bg-white dark:bg-gray-800 px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10 dark:sm:ring-white/10">
          <div className="flex items-center justify-between">
            <Link
              to="/"
              className="-m-1.5 p-1.5"
              onClick={() => setMobileMenuOpen(false)}
            >
              <span className="sr-only">Your Company</span>
              <img
                alt="Company Logo"
                src="https://tailwindcss.com/img/logos/mark.svg?color=indigo&shade=600"
                className="h-8 w-auto"
              />
            </Link>
            <button
              type="button"
              onClick={() => setMobileMenuOpen(false)}
              className="-m-2.5 rounded-md p-2.5 text-gray-700 dark:text-gray-300"
            >
              <span className="sr-only">Close menu</span>
              <XMarkIcon aria-hidden="true" className="size-6" />
            </button>
          </div>
          <div className="mt-6 flow-root">
            <div className="-my-6 divide-y divide-gray-500/10 dark:divide-gray-700">
              <div className="space-y-2 py-6">
                {/* Product 드롭다운 (모바일) */}
                <Disclosure as="div" className="-mx-3">
                  <DisclosureButton className="group flex w-full items-center justify-between rounded-lg py-2 pr-3.5 pl-3 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700">
                    Product
                    <ChevronDownIcon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500 group-data-open:rotate-180"
                    />
                  </DisclosureButton>
                  <DisclosurePanel className="mt-2 space-y-2">
                    {[...products, ...callsToAction].map((item) => (
                      <DisclosureButton
                        key={item.name}
                        as="a"
                        href={item.href}
                        onClick={() => setMobileMenuOpen(false)}
                        className="block rounded-lg py-2 pr-3 pl-6 text-sm/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                      >
                        {item.name}
                      </DisclosureButton>
                    ))}
                  </DisclosurePanel>
                </Disclosure>
                {/* 주요 메뉴들 */}
                <Link
                  to="/timeline"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Timeline
                </Link>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Marketplace
                </a>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Company
                </a>
              </div>
              <div className="py-6">
                {/* 다크모드 토글 (모바일) */}
                <button
                  onClick={() => {
                    toggleDarkMode();
                    setMobileMenuOpen(false);
                  }}
                  className="-mx-3 flex items-center gap-x-2 w-full rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                  aria-label="Toggle dark mode"
                >
                  {darkMode ? (
                    <SunIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  ) : (
                    <MoonIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  )}
                  {darkMode ? "라이트 모드" : "다크 모드"}
                </button>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Log in
                </a>
              </div>
            </div>
          </div>
        </DialogPanel>
      </Dialog>
    </header>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\store.js -----

import { create } from "zustand";

export const useSelectionStore = create((set) => ({
  /* —— A. 테이블·타임라인 동기 선택 —— */
  selectedRow: null,
  source: null, // 'table' or 'timeline'
  setSelectedRow: (row, src) => set({ selectedRow: row, source: src }),

  /* —— B. 드릴다운 상태 —— */
  lineId: "",
  sdwtId: "",
  eqpId: "",
  setLine: (id) => set({ lineId: id, sdwtId: "", eqpId: "" }),
  setSdwt: (id) => set({ sdwtId: id, eqpId: "" }),
  setEqp: (id) => set({ eqpId: id }),

  /* —— C. vis-timeline 인스턴스 풀 —— */
  pool: [],
  register: (tl) => set((s) => ({ pool: [...s.pool, tl] })),
  unregister: (tl) => set((s) => ({ pool: s.pool.filter((t) => t !== tl) })),

  // 모든 타임라인의 “보이는 구간”을 동기화
  syncRange: (self, start, end) =>
    set((state) => {
      state.pool.forEach((tl) => {
        if (tl !== self) tl.setWindow(start, end, { animation: false });
      });
      return state; // immer 없이 순수 set
    }),
}));


----- C:\Users\pjw75\Desktop\eqp-timeline\src\styles\timeline.css -----

/* ─────────────────────────────────────────────────────────────────────────
   vis-timeline 커스터마이징
───────────────────────────────────────────────────────────────────────── */

.timeline-container { margin-bottom: 16px; }

/* 공통 아이템 */
.vis-item {
  @apply border border-transparent text-slate-800;
  border-radius: 0 !important;
  margin-right: -1px;
  box-shadow: none !important;
  pointer-events: all !important;
}
.dark .vis-item { @apply text-slate-100; }

/* 상태 색상 */
.vis-item.bg-red-500    { @apply bg-red-500 border-red-600; }
.vis-item.bg-green-500  { @apply bg-green-500 border-green-600; }
.vis-item.bg-blue-500   { @apply bg-blue-500 border-blue-600; }
.vis-item.bg-yellow-500 { @apply bg-yellow-500 border-yellow-600; }
.vis-item.bg-gray-300   { @apply bg-gray-300 border-gray-400; }
/* 600 계열 */
.vis-item.bg-red-600    { @apply bg-red-600  border-red-700; }
.vis-item.bg-blue-600   { @apply bg-blue-600 border-blue-700; }
.vis-item.bg-yellow-600 { @apply bg-yellow-600 border-yellow-700; }
.vis-item.bg-green-600  { @apply bg-green-600 border-green-700; }
.vis-item.bg-amber-600  { @apply bg-amber-600 border-amber-700; }

/* 선택 아이템 */
.vis-item.vis-selected {
  outline: 2px dashed #fb923c !important;  
  outline-offset: -2px !important;              
  background-color: rgba(251, 146, 60, 0.2) !important; 
  filter: brightness(1.1) !important;
  z-index: 10 !important;
}

/* 레인지/포인트 */
.vis-item.vis-range { pointer-events: all !important; min-height: 20px !important; }
.vis-item.vis-point { pointer-events: all !important; }

/* 시간축 텍스트 */
.vis-time-axis .vis-text,
.vis-time-axis .vis-label { font-size: 13px !important; color: #334155; }
.dark .vis-time-axis .vis-text,
.dark .vis-time-axis .vis-label { color: #f1f5f9 !important; }

/* 그룹 라벨 */
.vis-label.custom-group-label { color: #334155; }
.dark .vis-label.custom-group-label { color: #f1f5f9 !important; }

/* 테이블 스크롤바 */
.table-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
.table-scroll::-webkit-scrollbar-track { background: #ffffff; border-radius: 10px; }
.table-scroll::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; border: 1px solid #e2e8f0; }
.dark .table-scroll::-webkit-scrollbar-track { background: #1e293b; }
.dark .table-scroll::-webkit-scrollbar-thumb { background: #475569; border: 1px solid #1e293b; }
.dark .table-scroll::-webkit-scrollbar-thumb:hover { background: #64748b; }


----- C:\Users\pjw75\Desktop\eqp-timeline\src\App.css -----


----- C:\Users\pjw75\Desktop\eqp-timeline\src\App.jsx -----

import React, { Suspense, lazy } from "react";
import { Routes, Route, Link } from "react-router-dom";
import Navbar from "@/shared/Navbar";
import LoadingSpinner from "@/shared/LoadingSpinner";

const TimelinePage = lazy(() => import("@/pages/TimelinePage"));

const HomePage = () => (
  <div className="p-6 text-center">
    <h1 className="text-2xl font-bold">홈페이지 🎉</h1>
    <p>
      상단의{" "}
      <Link className="text-indigo-600" to="/timeline">
        Timeline
      </Link>{" "}
      메뉴를 눌러 EQP 로그를 확인하세요.
    </p>
  </div>
);

export default function App() {
  return (
    <div className="h-screen flex flex-col overflow-hidden">
      <Navbar />
      <div className="flex-1 overflow-hidden px-6">
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route
            path="/timeline"
            element={
              <Suspense
                fallback={
                  <div className="flex items-center justify-center h-[80vh]">
                    <LoadingSpinner />
                  </div>
                }
              >
                <TimelinePage />
              </Suspense>
            }
          />
        </Routes>
      </div>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\index.css -----

@import "tailwindcss";

/* === vis-timeline 공통 스타일 === */
@custom-variant dark (&:where(.dark, .dark *));
@import "./styles/timeline.css";

----- C:\Users\pjw75\Desktop\eqp-timeline\src\main.jsx -----

import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useSelectionStore } from "@/shared/store"; // 초기화 용도
import App from "@/App";
import "@/index.css";

const qc = new QueryClient();

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <QueryClientProvider client={qc}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </StrictMode>
);


----- C:\Users\pjw75\Desktop\eqp-timeline\eslint.config.js -----

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


----- C:\Users\pjw75\Desktop\eqp-timeline\index.html -----

<!doctype html>
<html lang="en" class="bg-slate-50 dark:bg-slate-900">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EQP Timeline Viewer</title>
    <script>
      // 다크모드 초기화
      if (
        localStorage.theme === 'dark' ||
        (!localStorage.getItem('theme') &&
          window.matchMedia('(prefers-color-scheme: dark)').matches)
      ) {
        document.documentElement.classList.add('dark');
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


----- C:\Users\pjw75\Desktop\eqp-timeline\tailwind.config.js -----

/** @type {import('tailwindcss').Config} */
export default {
  darkMode: "class", // 버튼으로 다크모드 토글
  content: [
    "./index.html",
    "./src/**/*.{js,jsx}", // 템플릿 경로 (필수)
  ],
  theme: { extend: {} },
  plugins: [require("@tailwindcss/forms")],
};


----- C:\Users\pjw75\Desktop\eqp-timeline\vite.config.js -----

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite"; // ✅ v4용 Vite 플러그인
import path from "node:path";

export default defineConfig({
  plugins: [
    react({
      // 선택) React Fast-Refresh & props-on-export 경고 제어 등
    }),
    tailwindcss(), // ← PostCSS도 자동 연결
  ],

  resolve: {
    // '@/foo' → 'src/foo'
    alias: { "@": path.resolve(__dirname, "src") },
  },

  server: {
    host: "0.0.0.0", // LAN 공유 필요 없으면 지워도 무방
    port: 5173, // 기본값 5173, 충돌 시 변경
  },

  // 선택) 환경변수 프리픽스 늘리기
  envPrefix: ["VITE_", "PUBLIC_"],

  // 선택) 빌드 출력 경로·크기 경고
  build: {
    outDir: "dist",
    chunkSizeWarningLimit: 800,
  },
});

