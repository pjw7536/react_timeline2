
----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\app\App.jsx -----

// src/app/App.jsx
import React, { Suspense, lazy } from "react";
import { Routes, Route } from "react-router-dom";
import Navbar from "@layouts/MainLayout/Navbar";
import { LoadingSpinner } from "@shared/components";

const TimelinePage = lazy(() =>
  import("@features/timeline/pages/TimelinePage")
);
const AppsPage = lazy(() => import("@features/apps/pages/AppsPage"));

const HomePage = () => (
  <div className="p-6 text-center">
    <h1 className="text-2xl font-bold">홈페이지 🎉</h1>
    {/* ... */}
  </div>
);

export default function App() {
  return (
    <div className="h-screen flex flex-col overflow-hidden">
      <Navbar />
      <div className="flex-1 overflow-hidden px-4">
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route
            path="/timeline"
            element={
              <Suspense
                fallback={
                  <div className="flex items-center justify-center h-[80vh]">
                    <LoadingSpinner />
                  </div>
                }
              >
                <TimelinePage />
              </Suspense>
            }
          />
          <Route
            path="/timeline/:lineId/:eqpId"
            element={
              <Suspense
                fallback={
                  <div className="flex items-center justify-center h-[80vh]">
                    <LoadingSpinner />
                  </div>
                }
              >
                <TimelinePage />
              </Suspense>
            }
          />
          <Route path="/apps" element={<AppsPage />} />
        </Routes>
      </div>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\app\main.jsx -----

// src/app/main.jsx
import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import App from "./App";
import "@shared/styles/index.css";

const qc = new QueryClient();

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <QueryClientProvider client={qc}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </StrictMode>
);


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\app\routes.jsx -----

import React from "react";
import { Routes, Route } from "react-router-dom";
import { TimelinePage } from "@features/timeline";
import { AppsPage } from "@features/apps";

const HomePage = () => (
  <div className="p-6 text-center">
    <h1 className="text-2xl font-bold">홈페이지 🎉</h1>
    {/* ... */}
  </div>
);

export default function AppRoutes() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/timeline" element={<TimelinePage />} />
      <Route path="/timeline/:lineId/:eqpId" element={<TimelinePage />} />
      <Route path="/apps" element={<AppsPage />} />
    </Routes>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\apps\pages\AppsPage.jsx -----

import React, { useState, useMemo } from "react";
import { Search, Download, Globe, Shield } from "lucide-react";

// 회사 내부 앱/웹사이트 데이터
const appsData = [
  {
    id: 1,
    name: "ERP System",
    category: "업무시스템",
    rating: 4.2,
    users: "전체 직원",
    icon: "📊",
    description: "전사 자원 관리 시스템. 재무, 인사, 구매 등 통합 관리",
    screenshots: [],
    price: "무료",
    webUrl: "https://erp.company.local",
    downloadUrl: "/downloads/apps/ERP_Setup_v3.2.1.exe",
    lastUpdated: "2025-01-15",
    size: "156 MB",
    version: "3.2.1",
  },
  {
    id: 2,
    name: "HR Portal",
    category: "인사관리",
    rating: 4.5,
    users: "전체 직원",
    icon: "👥",
    description: "급여명세서, 휴가신청, 증명서 발급 등 인사 업무 처리",
    price: "무료",
    webUrl: "https://hr.company.local",
    downloadUrl: null,
    lastUpdated: "2025-01-20",
    isWebOnly: true,
  },
  {
    id: 3,
    name: "VPN Client",
    category: "보안도구",
    rating: 4.0,
    users: "재택근무자",
    icon: "🔒",
    description: "안전한 원격 접속을 위한 회사 VPN 클라이언트",
    price: "무료",
    webUrl: null,
    downloadUrl: "/downloads/apps/CompanyVPN_v2.1.0.exe",
    lastUpdated: "2025-01-10",
    size: "45 MB",
    version: "2.1.0",
    requirements: "Windows 10 이상",
  },
  {
    id: 4,
    name: "품질관리 시스템",
    category: "생산관리",
    rating: 4.3,
    users: "생산팀, 품질팀",
    icon: "✅",
    description: "제품 품질 검사 데이터 입력 및 분석 시스템",
    price: "무료",
    webUrl: "https://qms.company.local",
    downloadUrl: "/downloads/apps/QMS_Client_v1.5.2.exe",
    lastUpdated: "2025-01-18",
    size: "89 MB",
    version: "1.5.2",
  },
  {
    id: 5,
    name: "메신저 Plus",
    category: "커뮤니케이션",
    rating: 4.6,
    users: "전체 직원",
    icon: "💬",
    description: "사내 메신저. 파일 공유, 화상회의 기능 포함",
    price: "무료",
    webUrl: null,
    downloadUrl: "/downloads/apps/MessengerPlus_v4.0.1.exe",
    lastUpdated: "2025-01-22",
    size: "120 MB",
    version: "4.0.1",
  },
  {
    id: 6,
    name: "문서보안 솔루션",
    category: "보안도구",
    rating: 3.8,
    users: "전체 직원",
    icon: "🛡️",
    description: "기밀문서 암호화 및 권한 관리 프로그램",
    price: "무료",
    webUrl: null,
    downloadUrl: "/downloads/apps/DocSecurity_v2.3.0.exe",
    lastUpdated: "2025-01-12",
    size: "67 MB",
    version: "2.3.0",
    requirements: "Windows 10 이상, 관리자 권한 필요",
  },
  {
    id: 7,
    name: "재고관리 시스템",
    category: "생산관리",
    rating: 4.1,
    users: "물류팀, 구매팀",
    icon: "📦",
    description: "실시간 재고 현황 조회 및 입출고 관리",
    price: "무료",
    webUrl: "https://inventory.company.local",
    lastUpdated: "2025-01-19",
    isWebOnly: true,
  },
  {
    id: 8,
    name: "업무일지 작성기",
    category: "업무시스템",
    rating: 4.4,
    users: "전체 직원",
    icon: "📝",
    description: "일일 업무 보고서 작성 및 관리 도구",
    price: "무료",
    webUrl: "https://report.company.local",
    downloadUrl: "/downloads/apps/WorkReport_v1.2.0.exe",
    lastUpdated: "2025-01-21",
    size: "32 MB",
    version: "1.2.0",
  },
];

const categories = [
  "전체",
  "업무시스템",
  "인사관리",
  "생산관리",
  "보안도구",
  "커뮤니케이션",
];

// 앱 카드 컴포넌트
function AppCard({ app, onClick }) {
  const handleWebClick = (e) => {
    e.stopPropagation();
    if (app.webUrl) {
      window.open(app.webUrl, "_blank");
    }
  };

  const handleDownload = (e) => {
    e.stopPropagation();
    const downloadLink = app.downloadUrl;

    if (downloadLink) {
      if (
        window.confirm(
          `${app.name} ${
            app.version || ""
          }을(를) 다운로드하시겠습니까?\n\n파일 크기: ${
            app.size || "알 수 없음"
          }`
        )
      ) {
        window.location.href = downloadLink;
      }
    } else if (app.isWebOnly) {
      alert("이 서비스는 웹에서만 이용 가능합니다.");
    }
  };

  return (
    <div
      className="bg-white dark:bg-slate-800 rounded-xl p-4 shadow hover:shadow-lg hover:bg-blue-100 dark:hover:bg-slate-700 transition-all 
      duration-300 cursor-pointer border border-slate-200 dark:border-slate-700 flex flex-col w-59 h-60 overflow-hidden relative"
      onClick={() => onClick(app)}
    >
      {/* 카테고리 - 왼쪽 상단 */}
      <div className="absolute top-2 left-2">
        <span className="px-2 py-1 bg-slate-100 dark:bg-slate-700 rounded text-slate-700 dark:text-slate-300 text-xs">
          {app.category}
        </span>
      </div>

      {/* 버전 - 오른쪽 상단 */}
      {app.version && (
        <div className="absolute top-2 right-2">
          <span className="text-slate-500 dark:text-slate-400 text-xs">
            v{app.version}
          </span>
        </div>
      )}

      <div className="flex flex-col items-center text-center flex-grow overflow-hidden pt-6">
        <div className="text-3xl mb-2">{app.icon}</div>
        <h3 className="font-semibold text-slate-900 dark:text-white text-xs mb-1 truncate w-full">
          {app.name}
        </h3>
        <p className="text-xs text-slate-600 dark:text-slate-300 line-clamp-2 px-1 mt-3">
          {app.description}
        </p>
      </div>

      {/* 버튼 영역 - 항상 하단에 고정 */}
      <div className="flex gap-1 mt-2">
        {app.webUrl && (
          <button
            onClick={handleWebClick}
            className="flex-1 flex items-center justify-center gap-0.5 px-1 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-xs font-medium transition-colors"
          >
            <Globe className="w-3 h-5" />
            <span className="truncate">Web</span>
          </button>
        )}
        {app.downloadUrl && (
          <button
            onClick={handleDownload}
            className="flex-1 flex items-center justify-center gap-0.5 px-1 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-xs font-medium transition-colors"
          >
            <Download className="w-3 h-5" />
            <span className="truncate">설치</span>
          </button>
        )}
        {app.isWebOnly && !app.webUrl && (
          <span className="flex-1 text-center px-1 py-1 bg-slate-100 dark:bg-slate-700 text-slate-600 dark:text-slate-400 rounded text-xs">
            웹 전용
          </span>
        )}
      </div>
    </div>
  );
}

// 앱 상세 모달
function AppDetailModal({ app, onClose }) {
  if (!app) return null;

  const handleDownload = () => {
    const downloadLink = app.downloadUrl;
    if (downloadLink) {
      if (
        window.confirm(
          `${app.name} ${
            app.version || ""
          }을(를) 다운로드하시겠습니까?\n\n파일 크기: ${
            app.size || "알 수 없음"
          }`
        )
      ) {
        window.location.href = downloadLink;
      }
    }
  };

  return (
    <div
      className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-slate-800 rounded-xl max-w-xl w-full max-h-[90vh] overflow-y-auto shadow-2xl"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="p-6">
          <div className="flex justify-between items-start mb-6">
            <div className="flex gap-4">
              <div className="text-6xl">{app.icon}</div>
              <div>
                <h2 className="text-xl font-bold text-slate-900 dark:text-white">
                  {app.name}
                </h2>
                <p className="text-slate-600 text-sm dark:text-slate-400">
                  {app.category}
                </p>
              </div>
            </div>
            <button
              onClick={onClose}
              className="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg transition-colors"
            >
              <svg
                className="w-6 h-6"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </div>

          <div className="space-y-4">
            <div>
              <h3 className="font-semibold text-slate-900 text-xs dark:text-white mb-2">
                설명
              </h3>
              <p className="text-slate-700 text-xs dark:text-slate-300">
                {app.description}
              </p>
            </div>

            <div className="grid grid-cols-2 gap-4 py-4 border-y border-slate-200 dark:border-slate-700">
              <div>
                <p className="text-xs text-slate-500 dark:text-slate-400">
                  버전
                </p>
                <p className="font-medium text-xs text-slate-900 dark:text-white">
                  {app.version || "N/A"}
                </p>
              </div>
              <div>
                <p className="text-xs text-slate-500 dark:text-slate-400">
                  파일 크기
                </p>
                <p className="font-medium text-xs text-slate-900 dark:text-white">
                  {app.size || "N/A"}
                </p>
              </div>
              <div>
                <p className="text-xs text-slate-500 text-xs dark:text-slate-400">
                  최종 업데이트
                </p>
                <p className="font-medium text-slate-900 text-xs dark:text-white">
                  {app.lastUpdated}
                </p>
              </div>
              <div>
                <p className="text-xs text-slate-500 text-xs dark:text-slate-400">
                  사용 대상
                </p>
                <p className="font-medium text-slate-900 text-xs dark:text-white">
                  {app.users}
                </p>
              </div>
            </div>

            {app.requirements && (
              <div>
                <h3 className="font-semibold text-xs text-slate-900 dark:text-white mb-2">
                  시스템 요구사항
                </h3>
                <p className="text-xs text-slate-600 text-xs dark:text-slate-400">
                  {app.requirements}
                </p>
              </div>
            )}

            <div className="space-y-3">
              <h3 className="font-semibold text-slate-900 text-xs dark:text-white">
                접속/다운로드
              </h3>

              {app.webUrl && (
                <button
                  onClick={() => window.open(app.webUrl, "_blank")}
                  className="w-full flex items-center gap-3 p-4 bg-blue-50 dark:bg-blue-900/20 hover:bg-blue-100 dark:hover:bg-blue-900/30 rounded-lg transition-colors text-left"
                >
                  <Globe className="w-6 h-6 text-blue-600 dark:text-blue-400" />
                  <div>
                    <div className="font-medium text-xs text-slate-900 dark:text-white">
                      웹 버전 접속
                    </div>
                    <div className="text-xs text-slate-600 dark:text-slate-400">
                      {app.webUrl}
                    </div>
                  </div>
                </button>
              )}

              {app.downloadUrl && (
                <button
                  onClick={handleDownload}
                  className="w-full flex items-center gap-3 p-4 bg-slate-50 dark:bg-slate-700 hover:bg-slate-100 dark:hover:bg-slate-600 rounded-lg transition-colors text-left"
                >
                  <div className="w-6 h-6 text-blue-600">💻</div>
                  <div>
                    <div className="font-medium text-xs text-slate-900 dark:text-white">
                      Windows 버전
                    </div>
                    <div className="text-xs text-slate-600 dark:text-slate-400">
                      {app.downloadUrl}
                    </div>
                  </div>
                </button>
              )}

              {app.isWebOnly && (
                <div className="p-4 bg-slate-50 dark:bg-slate-700 rounded-lg">
                  <p className="text-xs text-slate-600 dark:text-slate-400">
                    이 서비스는 웹 브라우저를 통해서만 이용 가능합니다.
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// 메인 앱스토어 컴포넌트
export default function AppsPage() {
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedCategory, setSelectedCategory] = useState("전체");
  const [selectedApp, setSelectedApp] = useState(null);

  // 필터링된 앱 목록
  const filteredApps = useMemo(() => {
    let apps = appsData.filter((app) => {
      const matchesSearch =
        app.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        app.description.toLowerCase().includes(searchTerm.toLowerCase());
      const matchesCategory =
        selectedCategory === "전체" || app.category === selectedCategory;
      return matchesSearch && matchesCategory;
    });

    return apps;
  }, [searchTerm, selectedCategory]);

  return (
    <div className="flex flex-row h-[calc(100vh-85px)] gap-2 mt-3">
      {/* 왼쪽: 필터 섹션 */}
      <div className="flex flex-col h-full min-h-0 w-[13%] gap-2">
        {/* 안내 메시지 섹션 */}
        <section className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 min-h-0 overflow-auto flex-[1]">
          <div className="space-y-3">
            <div className="flex items-start gap-2">
              <Shield className="w-4 h-4 text-blue-600 dark:text-blue-400 mt-0.5 flex-shrink-0" />
              <div className="text-xs text-blue-800 dark:text-blue-200">
                <p className="font-medium mb-1">안내</p>
                <p className="text-xs">
                  모든 사내 프로그램은 승인된 기기에서만 설치 가능합니다.
                </p>
              </div>
            </div>
          </div>
        </section>
        {/* 검색 및 필터 섹션 */}
        <section className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex flex-col flex-[8]">
          <h2 className="text-sm font-bold text-slate-900 dark:text-white mb-3">
            🔍 앱 검색
          </h2>

          {/* 검색창 */}
          <div className="relative mb-4">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 text-slate-400" />
            <input
              type="text"
              placeholder="시스템명 검색..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full pl-10 pr-4 py-2 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs text-slate-900 dark:text-white placeholder-slate-500 focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>

          <hr className="my-2 border-slate-300 dark:border-slate-600" />

          {/* 카테고리 필터 */}
          <div className="mt-2">
            <h3 className="text-xs font-semibold text-slate-900 dark:text-white mb-3">
              카테고리
            </h3>
            <div className="space-y-2">
              {categories.map((category) => (
                <button
                  key={category}
                  onClick={() => setSelectedCategory(category)}
                  className={`w-full text-left px-4 py-2 rounded-lg text-xs font-medium transition-colors ${
                    selectedCategory === category
                      ? "bg-blue-600 text-white"
                      : "bg-slate-100 dark:bg-slate-700 text-slate-700 dark:text-slate-300 hover:bg-slate-200 dark:hover:bg-slate-600"
                  }`}
                >
                  {category}
                </button>
              ))}
            </div>
          </div>
        </section>
      </div>

      {/* 오른쪽: 앱 목록 */}
      <div className="w-[87%] h-full overflow-hidden bg-white dark:bg-slate-800 shadow rounded-xl px-3 pt-5">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-md font-bold text-slate-900 dark:text-white">
            💼 사내 시스템 & 도구
          </h2>
          <span className="text-xs text-slate-600 dark:text-slate-400">
            Total: {filteredApps.length}
          </span>
        </div>
        <hr className="mb-4 border-slate-300 dark:border-slate-600" />

        {filteredApps.length === 0 ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-center text-slate-600 dark:text-slate-400">
              검색 결과가 없습니다.
            </p>
          </div>
        ) : (
          <div className="flex flex-wrap gap-2 items-start content-start overflow-y-auto h-[calc(100%-60px)]">
            {filteredApps.map((app) => (
              <AppCard key={app.id} app={app} onClick={setSelectedApp} />
            ))}
          </div>
        )}
      </div>

      {/* 앱 상세 모달 */}
      {selectedApp && (
        <AppDetailModal
          app={selectedApp}
          onClose={() => setSelectedApp(null)}
        />
      )}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\apps\index.js -----

export { default as AppsPage } from './pages/AppsPage';


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\drilldown\hooks\useLineQueries.js -----

import { useQuery } from "@tanstack/react-query";
import { timelineApi } from "@/features/timeline/api/timelineApi";

// ① 라인 목록 (언제나 요청)
export const useLines = () =>
  useQuery({
    queryKey: ["lines"],
    queryFn: timelineApi.fetchLines,
    staleTime: 1000 * 60 * 30,
  });

// ② SDWT 목록 (lineId 가 있어야 동작)
export const useSDWT = (lineId) =>
  useQuery({
    queryKey: ["sdwts", lineId],
    queryFn: () => timelineApi.fetchSDWT(lineId),
    enabled: !!lineId,
    staleTime: 1000 * 60 * 30,
  });

// ③ PRC Group 목록 (lineId와 sdwtId가 있어야 동작)
export const usePrcGroups = (lineId, sdwtId) =>
  useQuery({
    queryKey: ["prcGroups", lineId, sdwtId],
    queryFn: () => timelineApi.fetchPrcGroups(lineId, sdwtId),
    enabled: !!lineId && !!sdwtId,
    staleTime: 1000 * 60 * 30,
  });

// ④ EQP 목록 (line + sdwt + prcGroup 모두 골랐을 때만)
export const useEquipments = (lineId, sdwtId, prcGroup) =>
  useQuery({
    queryKey: ["equipments", lineId, sdwtId, prcGroup],
    queryFn: () => timelineApi.fetchEquipments(lineId, sdwtId, prcGroup),
    enabled: !!lineId && !!sdwtId && !!prcGroup,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\drilldown\EqpSelector.jsx -----

// src/features/drilldown/EqpSelector.jsx
import React from "react";
import { useEquipments } from "./hooks/useLineQueries";
import { LoadingSpinner } from "@shared/components";

/**
 * EQP 드롭다운
 */
export default function EqpSelector({
  lineId,
  sdwtId,
  prcGroup,
  eqpId,
  setEqpId,
}) {
  // 데이터·상태 가져오기 - prcGroup 추가
  const { data: eqps = [], isLoading } = useEquipments(
    lineId,
    sdwtId,
    prcGroup
  );

  // Line, SDWT, PRC Group 모두 선택해야 활성화
  if (!lineId || !sdwtId || !prcGroup)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 h-8"
      >
        <option>EQP 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={eqpId}
      onChange={(e) => setEqpId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
      disabled={eqps.length === 0}
    >
      <option value="">EQP 선택…</option>
      {eqps.map((e) => (
        <option key={e.id} value={e.id}>
          {e.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\drilldown\index.js -----

// src/features/drilldown/index.js
export { default as LineSelector } from "./LineSelector";
export { default as SDWTSelector } from "./SDWTSelector";
export { default as PrcGroupSelector } from "./PrcGroupSelector";
export { default as EqpSelector } from "./EqpSelector";


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\drilldown\LineSelector.jsx -----

import React from "react";
import { useLines } from "./hooks/useLineQueries";
import { LoadingSpinner } from "@shared/components";

/**
 * 라인 목록 드롭다운
 */
export default function LineSelector({ lineId, setLineId }) {
  const { data: lines = [], isLoading } = useLines();

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={lineId}
      onChange={(e) => setLineId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
    >
      <option value="">라인 선택…</option>
      {lines.map((l) => (
        <option key={l.id} value={l.id}>
          {l.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\drilldown\PrcGroupSelector.jsx -----

// src/features/drilldown/PrcGroupSelector.jsx
import React from "react";
import { usePrcGroups } from "./hooks/useLineQueries";
import { LoadingSpinner } from "@shared/components";

/**
 * PRC Group 드롭다운
 */
export default function PrcGroupSelector({
  lineId,
  sdwtId,
  prcGroup,
  setPrcGroup,
}) {
  const { data: prcGroups = [], isLoading } = usePrcGroups(lineId, sdwtId);

  if (!lineId || !sdwtId)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 h-8"
      >
        <option>PRC Group 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={prcGroup}
      onChange={(e) => setPrcGroup(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
      disabled={prcGroups.length === 0}
    >
      <option value="">PRC Group 선택…</option>
      {prcGroups.map((p) => (
        <option key={p.id} value={p.id}>
          {p.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\drilldown\SDWTSelector.jsx -----

import React from "react";
import { useSDWT } from "./hooks/useLineQueries";
import { LoadingSpinner } from "@shared/components";

/**
 * SDWT 드롭다운
 */
export default function SDWTSelector({ lineId, sdwtId, setSdwtId }) {
  const { data: sdwts = [], isLoading } = useSDWT(lineId);

  if (!lineId)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 h-8"
      >
        <option>SDWT 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={sdwtId}
      onChange={(e) => setSdwtId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
    >
      <option value="">SDWT 선택…</option>
      {sdwts.map((s) => (
        <option key={s.id} value={s.id}>
          {s.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\CtttmLogDetail.jsx -----

// src/features/table/components/logDetails/CtttmLogDetail.jsx
import React from "react";
import Field from "./Field";

export default function CtttmLogDetail({ log }) {
  return (
    <>
      <Field label="ID" value={log.id} />
      <Field label="Log Type" value={log.logType} />
      <Field label="CTTTM" value={log.eventType} />
      <Field label="Time" value={log.eventTime} />
      <Field label="Recipe" value={log.recipe} />
      <Field label="Operator" value={log.operator} />
      <Field label="Duration" value={log.duration?.toFixed(1)} />
      <Field
        label="Comment"
        value={log.comment}
        className="col-span-2"
        streaming={true}
      />
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\EqpLogDetail.jsx -----

// src/features/table/components/logDetails/EqpLogDetail.jsx
import React from "react";
import Field from "./Field";

export default function EqpLogDetail({ log }) {
  return (
    <>
      <Field label="ID" value={log.id} />
      <Field label="Log Type" value={log.logType} />
      <Field label="EQP State" value={log.eventType} />
      <Field label="Time" value={log.eventTime} />
      <Field label="End Time" value={log.endTime} />
      <Field label="Operator" value={log.operator} />
      <Field label="Duration" value={log.duration?.toFixed(1)} />
      <Field label="Comment" value={log.comment} className="col-span-2" />
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\Field.jsx -----

// src/features/table/components/logDetails/Field.jsx
import React from "react";
import StreamingText from "./StreamingText";

/**
 * 필드 공통 출력 컴포넌트
 */
export default function Field({
  label,
  value,
  className = "",
  streaming = false,
}) {
  return (
    <>
      <div
        className={`font-semibold text-slate-700 dark:text-slate-200 ${className}`}
      >
        {label}
      </div>
      <div>
        {streaming ? <StreamingText text={value || "-"} /> : value || "-"}
      </div>
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\JiraLogDetail.jsx -----

// src/features/table/components/logDetails/JiraLogDetail.jsx
import React from "react";
import Field from "./Field";
import UrlField from "./UrlField";

export default function JiraLogDetail({ log }) {
  return (
    <>
      <Field label="ID" value={log.id} />
      <Field label="Log Type" value={log.logType} />
      <Field label="Issue Status" value={log.eventType} />
      <Field label="Time" value={log.eventTime} />
      <Field label="Issue Key" value={log.issueKey} />
      <Field label="Assignee" value={log.assignee} />
      <Field label="Priority" value={log.priority} />
      <Field label="Reporter" value={log.reporter} />
      <Field label="Summary" value={log.summary} className="col-span-2" />
      <Field
        label="Description"
        value={log.description}
        className="col-span-2"
      />
      <UrlField url={log.url} />
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\RacbLogDetail.jsx -----

// src/features/table/components/logDetails/RacbLogDetail.jsx
import React from "react";
import Field from "./Field";
import UrlField from "./UrlField";

export default function RacbLogDetail({ log }) {
  return (
    <>
      <Field label="ID" value={log.id} />
      <Field label="Log Type" value={log.logType} />
      <Field label="RACB Alarm" value={log.eventType} />
      <Field label="Time" value={log.eventTime} />
      <Field label="Operator" value={log.operator} />
      <Field label="Comment" value={log.comment} className="col-span-2" />
      <UrlField url={log.url} />
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\StreamingText.jsx -----

// src/features/table/components/logDetails/StreamingText.jsx
import React, { useState, useEffect } from "react";

/**
 * 스트리밍 텍스트 애니메이션 컴포넌트
 */
export default function StreamingText({ text, speed = 30 }) {
  const [displayedText, setDisplayedText] = useState("");
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    setDisplayedText("");
    setCurrentIndex(0);
  }, [text]);

  useEffect(() => {
    if (currentIndex < text.length) {
      const timer = setTimeout(() => {
        setDisplayedText((prev) => prev + text[currentIndex]);
        setCurrentIndex((prev) => prev + 1);
      }, speed);

      return () => clearTimeout(timer);
    }
  }, [currentIndex, text, speed]);

  return (
    <span className="inline-block">
      {displayedText}
      {currentIndex < text.length && (
        <span className="inline-block w-2 h-4 bg-slate-600 dark:bg-slate-400 animate-pulse ml-0.5" />
      )}
    </span>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\TipLogDetail.jsx -----

// src/features/table/components/logDetails/TipLogDetail.jsx
import React from "react";
import Field from "./Field";
import UrlField from "./UrlField";

export default function TipLogDetail({ log }) {
  return (
    <>
      <Field label="ID" value={log.id} />
      <Field label="Log Type" value={log.logType} />
      <Field label="TIP Event" value={log.eventType} />
      <Field label="Time" value={log.eventTime} />
      <Field label="Operator" value={log.operator} />
      <Field label="Level" value={log.level} />
      <Field label="Comment" value={log.comment} className="col-span-2" />
      <UrlField url={log.url} />
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\logs\components\UrlField.jsx -----

// src/features/table/components/logDetails/UrlField.jsx
import React from "react";

/**
 * URL 필드 컴포넌트
 */
export default function UrlField({ url }) {
  if (!url) return null;

  return (
    <>
      <div className="font-semibold text-slate-700 dark:text-slate-200">
        URL
      </div>
      <div>
        <a
          href={url}
          className="text-blue-600 dark:text-blue-400 underline break-all"
          target="_blank"
          rel="noopener noreferrer"
        >
          {url}
        </a>
      </div>
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\table\components\LogDetailSection.jsx -----

import React, { useState, useEffect } from "react";

// 스트리밍 텍스트 컴포넌트
function StreamingText({ text, speed = 30 }) {
  const [displayedText, setDisplayedText] = useState("");
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    // 텍스트가 변경되면 초기화
    setDisplayedText("");
    setCurrentIndex(0);
  }, [text]);

  useEffect(() => {
    if (currentIndex < text.length) {
      const timer = setTimeout(() => {
        setDisplayedText((prev) => prev + text[currentIndex]);
        setCurrentIndex((prev) => prev + 1);
      }, speed);

      return () => clearTimeout(timer);
    }
  }, [currentIndex, text, speed]);

  return (
    <span className="inline-block">
      {displayedText}
      {currentIndex < text.length && (
        <span className="inline-block w-2 h-4 bg-slate-600 dark:bg-slate-400 animate-pulse ml-0.5" />
      )}
    </span>
  );
}

// 필드 공통 출력용
function Field({ label, value, className, streaming = false }) {
  return (
    <>
      <div
        className={
          "font-semibold text-slate-700 dark:text-slate-200 " +
          (className || "")
        }
      >
        {label}
      </div>
      <div>{streaming ? <StreamingText text={value || "-"} /> : value}</div>
    </>
  );
}

function UrlField({ url }) {
  return (
    <>
      <div className="font-semibold text-slate-700 dark:text-slate-200">
        URL
      </div>
      <div>
        <a
          href={url}
          className="text-blue-600 dark:text-blue-400 underline break-all"
          target="_blank"
          rel="noopener noreferrer"
        >
          {url}
        </a>
      </div>
    </>
  );
}

// 로그 타입별 렌더러
function renderDetailByType(log) {
  switch (log.logType) {
    case "EQP":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="EQP State" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="End Time" value={log.endTime ?? "-"} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field label="Duration" value={log.duration?.toFixed(1) ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
          />
        </>
      );
    case "TIP":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="TIP Event" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field label="Level" value={log.level ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
          />
          {log.url && <UrlField url={log.url} />}
        </>
      );
    case "RACB":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="RACB Alarm" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
          />
          {log.url && <UrlField url={log.url} />}
        </>
      );
    case "CTTTM":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="CTTTM" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Recipe" value={log.recipe ?? "-"} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field label="Duration" value={log.duration?.toFixed(1) ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
            streaming={true} // CTTTM의 Comment만 스트리밍 효과 적용
          />
        </>
      );
    case "JIRA":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="Issue Status" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Issue Key" value={log.issueKey ?? "-"} />
          <Field label="Assignee" value={log.assignee ?? "-"} />
          <Field label="Priority" value={log.priority ?? "-"} />
          <Field label="Reporter" value={log.reporter ?? "-"} />
          <Field
            label="Summary"
            value={log.summary ?? "-"}
            className="col-span-2"
          />
          <Field
            label="Description"
            value={log.description ?? "-"}
            className="col-span-2"
          />
          {log.url && <UrlField url={log.url} />}
        </>
      );
    default:
      return (
        <div className="col-span-2 text-slate-500 dark:text-slate-400 py-2">
          알 수 없는 로그 타입입니다.
        </div>
      );
  }
}

/**
 * 선택된 로그 상세정보를 보여주는 컴포넌트
 * @param {Object} log - 상세를 보여줄 로그 객체
 */
export default function LogDetailSection({ log }) {
  if (!log) {
    return (
      <div className="text-sm text-slate-500 dark:text-slate-400 text-center py-17">
        테이블이나 타임라인에서 로그를 선택하면 상세정보가 표시됩니다.
      </div>
    );
  }

  return (
    <div
      className="grid grid-cols-2 gap-x-4 gap-y-2 text-xs
      bg-white dark:bg-slate-800 rounded-lg p-2
      text-slate-800 dark:text-slate-100 overflow-auto table-scroll"
    >
      {renderDetailByType(log)}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\table\components\VirtualizedDataTable.jsx -----

// src/features/table/VirtualizedDataTable.jsx
import React, { useEffect, useRef, useCallback, useMemo } from "react";
import { FixedSizeList as List } from "react-window";
import { useSelectionStore } from "@shared/store";

/**
 * 가상화된 데이터 테이블 컴포넌트
 * react-window를 사용하여 대량의 데이터도 부드럽게 렌더링
 */
export default function VirtualizedDataTable({
  data,
  typeFilters,
  handleFilter,
}) {
  const { selectedRow, source, setSelectedRow } = useSelectionStore();
  const listRef = useRef(null);
  const scrollAnimationRef = useRef(null);

  // 오버스캔 카운트 증가로 더 많은 행을 미리 렌더링
  const OVERSCAN_COUNT = 10;
  const ITEM_HEIGHT = 36;

  // 부드러운 스크롤 함수
  const smoothScrollTo = useCallback((targetOffset, duration = 200) => {
    if (!listRef.current) return;

    const startOffset = listRef.current.state.scrollOffset;
    const distance = targetOffset - startOffset;
    const startTime = performance.now();

    const animateScroll = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // easeInOutQuad 이징 함수
      const easeProgress =
        progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

      const currentOffset = startOffset + distance * easeProgress;

      // react-window의 scrollTo 메서드 사용
      listRef.current.scrollTo(currentOffset);

      if (progress < 1) {
        scrollAnimationRef.current = requestAnimationFrame(animateScroll);
      }
    };

    // 이전 애니메이션 취소
    if (scrollAnimationRef.current) {
      cancelAnimationFrame(scrollAnimationRef.current);
    }

    requestAnimationFrame(animateScroll);
  }, []);

  // 타임라인에서 선택된 항목이 있을 때 해당 행으로 스크롤
  useEffect(() => {
    if (
      source === "timeline" &&
      selectedRow &&
      listRef.current &&
      data.length > 0
    ) {
      const index = data.findIndex(
        (row) => String(row.id) === String(selectedRow)
      );

      if (index >= 0) {
        // 목표 위치 계산 (화면 중앙에 오도록)
        const listHeight = containerHeight;
        const targetOffset =
          index * ITEM_HEIGHT - listHeight / 2 + ITEM_HEIGHT / 2;
        const maxOffset = data.length * ITEM_HEIGHT - listHeight;
        const finalOffset = Math.max(0, Math.min(targetOffset, maxOffset));

        // 부드러운 스크롤 실행
        smoothScrollTo(finalOffset);
      }
    }
  }, [selectedRow, source, data, smoothScrollTo]);

  // 컴포넌트 언마운트 시 애니메이션 정리
  useEffect(() => {
    return () => {
      if (scrollAnimationRef.current) {
        cancelAnimationFrame(scrollAnimationRef.current);
      }
    };
  }, []);

  // 컬럼 너비 정의 (px 단위로 통일)
  const columnWidths = {
    time: 112,
    logType: 80,
    changeType: 160,
    operator: 70,
    duration: 70,
    url: 70,
  };

  // 헤더 컴포넌트
  const TableHeader = useMemo(
    () => (
      <div className="sticky top-0 z-10 bg-gray-200 text-gray-900 dark:bg-gray-600 dark:text-gray-100">
        <div className="flex text-xs font-semibold">
          <div
            style={{ width: `${columnWidths.time}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            Time
          </div>
          <div
            style={{ width: `${columnWidths.logType}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            LogType
          </div>
          <div
            style={{ width: `${columnWidths.changeType}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            ChangeType
          </div>
          <div
            style={{ width: `${columnWidths.operator}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            Operator
          </div>
          <div
            style={{ width: `${columnWidths.duration}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            Duration
          </div>
          <div
            style={{ width: `${columnWidths.url}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            URL
          </div>
        </div>
      </div>
    ),
    [columnWidths]
  );

  // 필터 체크박스 컴포넌트
  const FilterCheckboxes = useMemo(
    () => (
      <div className="flex gap-3 flex-wrap mr-3">
        {Object.entries(typeFilters).map(([type, checked]) => (
          <label
            key={type}
            className="flex items-center gap-1 text-xs font-bold"
          >
            <input
              type="checkbox"
              name={type}
              checked={checked}
              onChange={handleFilter}
              className="rounded border-gray-300 dark:border-slate-600"
            />
            {type.replace("_LOG", "")}
          </label>
        ))}
      </div>
    ),
    [typeFilters, handleFilter]
  );

  // 행 렌더링 함수 - React.memo로 최적화
  const Row = React.memo(({ index, style }) => {
    const row = data[index];
    const isSel = String(row.id) === String(selectedRow);

    const handleClick = () => {
      setSelectedRow(isSel ? null : row.id, "table");
    };

    const handleUrlClick = (e) => {
      e.stopPropagation();
      if (row.url) {
        window.open(row.url, "_blank", "noopener,noreferrer");
      }
    };

    return (
      <div
        style={{
          ...style,
          // will-change로 브라우저에 최적화 힌트 제공
          willChange: "transform",
        }}
        onClick={handleClick}
        className={`flex items-center cursor-pointer border-b border-gray-100 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 ${
          isSel
            ? "bg-yellow-200 dark:bg-yellow-800 dark:ring-yellow-700 transition-all duration-200"
            : "bg-white dark:bg-gray-800 transition-colors duration-150"
        }`}
      >
        <div
          style={{ width: `${columnWidths.time}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.displayTimestamp}
        </div>
        <div
          style={{ width: `${columnWidths.logType}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          <span
            className={`
            inline-block px-2 py-1 text-xs font-medium rounded
            ${
              row.logType === "EQP"
                ? "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
                : ""
            }
            ${
              row.logType === "TIP"
                ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
                : ""
            }
            ${
              row.logType === "RACB"
                ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"
                : ""
            }
            ${
              row.logType === "CTTTM"
                ? "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200"
                : ""
            }
            ${
              row.logType === "JIRA"
                ? "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200"
                : ""
            }
          `}
          >
            {row.logType}
          </span>
        </div>
        <div
          style={{ width: `${columnWidths.changeType}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.info1}
        </div>
        <div
          style={{ width: `${columnWidths.operator}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.info2}
        </div>
        <div
          style={{ width: `${columnWidths.duration}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.duration}
        </div>
        <div
          style={{ width: `${columnWidths.url}px` }}
          className="px-2 py-2 text-xs text-center flex-shrink-0"
        >
          {row.url ? (
            <button
              onClick={handleUrlClick}
              className="inline-flex items-center justify-center w-8 h-8 rounded hover:bg-blue-100 dark:hover:bg-blue-900 transition-colors"
              title="Open URL"
            >
              <svg
                className="w-4 h-4 text-blue-600 dark:text-blue-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
                />
              </svg>
            </button>
          ) : (
            <span className="text-gray-400 dark:text-gray-600">-</span>
          )}
        </div>
      </div>
    );
  });

  Row.displayName = "Row";

  // 리스트 컨테이너의 높이 계산
  const [containerHeight, setContainerHeight] = React.useState(400);
  const containerRef = useRef(null);

  useEffect(() => {
    const updateHeight = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const availableHeight = rect.height - 120;
        setContainerHeight(Math.max(200, availableHeight));
      }
    };

    updateHeight();
    window.addEventListener("resize", updateHeight);
    return () => window.removeEventListener("resize", updateHeight);
  }, []);

  return (
    <div className="h-full flex flex-col overflow-hidden" ref={containerRef}>
      {/* 상단 필터 영역 */}
      <div className="flex justify-between items-center pt-1 bg-white dark:bg-slate-800 text-gray-900 dark:text-white rounded-t-lg">
        <h3 className="text-md font-semibold mb-5">📜 Data Log</h3>
        {FilterCheckboxes}
      </div>

      {/* 테이블 영역 */}
      <div className="flex-1 overflow-hidden">
        {data.length === 0 ? (
          <div className="text-center text-sm text-gray-500 dark:text-gray-400 p-4">
            표시할 데이터가 없습니다.
          </div>
        ) : (
          <div className="h-full bg-white dark:bg-gray-800 rounded-b-lg overflow-hidden">
            {TableHeader}
            <List
              ref={listRef}
              height={containerHeight}
              itemCount={data.length}
              itemSize={ITEM_HEIGHT}
              width="100%"
              overscanCount={OVERSCAN_COUNT}
              className="scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100 dark:scrollbar-thumb-gray-600 dark:scrollbar-track-gray-800"
              style={{
                // 스크롤 성능 최적화
                contain: "strict",
                overflowAnchor: "none",
              }}
            >
              {Row}
            </List>
          </div>
        )}
      </div>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\table\index.js -----

export { default as VirtualizedDataTable } from './components/VirtualizedDataTable';
export { default as LogDetailSection } from './components/LogDetailSection';


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\api\timelineApi.js -----

import { apiClient } from "@shared/services/api/client";

export const timelineApi = {
  // "라인 목록" 엔드포인트
  fetchLines: () => apiClient("/lines"),

  // SDWT 목록
  fetchSDWT: (lineId) => apiClient("/sdwts", { params: { lineId } }),

  // PRC Group 목록
  fetchPrcGroups: (lineId, sdwtId) =>
    apiClient("/prc-groups", { params: { lineId, sdwtId } }),

  // Equipment 목록
  fetchEquipments: (lineId, sdwtId, prcGroup) => {
    const params = { lineId };
    if (sdwtId) params.sdwtId = sdwtId;
    if (prcGroup) params.prcGroup = prcGroup;
    return apiClient("/equipments", { params });
  },

  // 로그 가져오기 - sdwtId 제거
  fetchLogs: ({ lineId, eqpId }) =>
    apiClient("/logs", { params: { lineId, eqpId } }),

  // EQP 정보 조회
  fetchEquipmentInfo: (lineId, eqpId) =>
    apiClient(`/equipment-info/${lineId}/${eqpId}`),
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\BaseTimeline.jsx -----

import React, { useRef, useMemo } from "react";
import { useVisTimeline } from "../hooks/useVisTimeline";

/**
 * 재사용 가능한 기본 Timeline 컴포넌트
 * @param {Object} props
 * @param {Array} props.groups - 타임라인 그룹 정의
 * @param {Array} props.items - 타임라인 아이템
 * @param {Object} props.options - vis-timeline 옵션
 * @param {string} props.title - 타임라인 제목
 * @param {ReactNode} props.headerExtra - 헤더 추가 요소
 * @param {boolean} props.showTimeAxis - x축 표시 여부
 */
export default function BaseTimeline({
  groups,
  items,
  options = {},
  title,
  headerExtra,
  className = "",
  style = {},
  showTimeAxis = true,
}) {
  const containerRef = useRef(null);

  const mergedOptions = useMemo(
    () => ({
      margin: { item: 0, axis: 0 },
      groupOrder: "order",
      selectable: true,
      verticalScroll: true,
      tooltip: {
        followMouse: true,
        overflowMethod: "cap",
      },
      showMajorLabels: showTimeAxis,
      showMinorLabels: showTimeAxis,
      // 높이 관련 옵션
      ...options,
    }),
    [options, showTimeAxis]
  );

  useVisTimeline({
    containerRef,
    groups,
    items,
    options: mergedOptions,
  });

  // 동적 스타일 계산
  const containerStyle = useMemo(() => {
    const baseStyle = {
      ...style,
    };

    return baseStyle;
  }, [style]);

  return (
    <div
      className={`timeline-container relative ${className} ${
        !showTimeAxis ? "no-time-axis" : ""
      }`}
    >
      {(title || headerExtra) && (
        <div className="flex items-center justify-between mb-1">
          {title && (
            <h3 className="text-sm font-semibold text-slate-600 dark:text-slate-300">
              {title}
            </h3>
          )}
          {headerExtra}
        </div>
      )}

      <div ref={containerRef} className="timeline" style={containerStyle} />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\DataLogSection.jsx -----

// src/features/timeline/components/DataLogSection.jsx
import React from "react";
import VirtualizedDataTable from "@features/table/components/VirtualizedDataTable";
import { LoadingSpinner } from "@shared/components";

export default function DataLogSection({
  eqpId,
  logsLoading,
  tableData,
  typeFilters,
  handleFilter,
}) {
  return (
    <section className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex-[2] min-h-0 flex flex-col overflow-hidden">
      {!eqpId && !logsLoading ? (
        <p className="text-center text-sm text-slate-600 dark:text-slate-400 py-45">
          EQP를 선택하세요.
        </p>
      ) : logsLoading ? (
        <div className="flex items-center justify-center h-full">
          <LoadingSpinner />
        </div>
      ) : (
        <VirtualizedDataTable
          data={tableData}
          typeFilters={typeFilters}
          handleFilter={handleFilter}
        />
      )}
    </section>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\EqpTimeline.jsx -----

import React, { useMemo } from "react";
import BaseTimeline from "./BaseTimeline";
import { processData } from "../utils/timelineUtils";
import { makeGroupLabel } from "../utils/groupLabel";

export default function EqpTimeline({
  lineId,
  eqpId,
  range,
  showLegend,
  showTimeAxis = false,
  height = 10, // EQP는 단일 그룹이므로 낮은 높이
  eqpLogs = [], // props로 데이터 받기
}) {
  const groups = useMemo(
    () => [
      {
        id: "EQP",
        content: makeGroupLabel("EQP", "EQP 로그", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
        order: 1,
      },
    ],
    [showLegend]
  );

  const items = useMemo(() => processData("EQP", eqpLogs, true), [eqpLogs]);

  const options = useMemo(
    () => ({
      stack: false,
      min: range.min,
      max: range.max,
      zoomMin: 60 * 60 * 1000,
    }),
    [range]
  );

  return (
    <BaseTimeline
      groups={groups}
      items={items}
      options={options}
      title="⚙️ EQP 상태"
      showTimeAxis={showTimeAxis}
      height={height}
      minHeight={80}
      maxHeight={200}
      headerExtra={
        <span className="text-xs text-slate-500">{eqpLogs.length}개 로그</span>
      }
    />
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\EventTimeline.jsx -----

import React, { useMemo } from "react";
import BaseTimeline from "./BaseTimeline";
import { processData } from "../utils/timelineUtils";
import { makeGroupLabel } from "../utils/groupLabel";

// CTTTM, RACB, JIRA를 하나로 묶은 이벤트 타임라인
export default function EventTimeline({
  lineId,
  eqpId,
  range,
  showLegend,
  showTimeAxis = true,
  eventLogs = [], // props로 데이터 받기
}) {
  const groups = useMemo(
    () => [
      {
        id: "CTTTM",
        content: makeGroupLabel("CTTTM", "CTTTM", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
        order: 1,
      },
      {
        id: "RACB",
        content: makeGroupLabel("RACB", "RACB", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
        order: 2,
      },
      {
        id: "JIRA",
        content: makeGroupLabel("JIRA", "JIRA", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
        order: 3,
      },
    ],
    [showLegend]
  );

  const items = useMemo(() => {
    const ctttmItems = processData(
      "CTTTM",
      eventLogs.filter((l) => l.logType === "CTTTM")
    );
    const racbItems = processData(
      "RACB",
      eventLogs.filter((l) => l.logType === "RACB")
    );
    const jiraItems = processData(
      "JIRA",
      eventLogs.filter((l) => l.logType === "JIRA")
    );

    return [...ctttmItems, ...racbItems, ...jiraItems];
  }, [eventLogs]);

  const options = useMemo(
    () => ({
      stack: true,
      min: range.min,
      max: range.max,
      zoomMin: 60 * 60 * 1000,
      height: 200,
    }),
    [range]
  );

  return (
    <BaseTimeline
      groups={groups}
      items={items}
      options={options}
      title="📍 이벤트 로그"
      showTimeAxis={showTimeAxis}
      style={{ height: "200px" }}
    />
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\LegendToggle.jsx -----

// src/features/timeline/components/LegendToggle.jsx
import React from "react";

export default function LegendToggle({ showLegend, onToggle }) {
  return (
    <label className="inline-flex items-center cursor-pointer">
      <span className="text-xs font-medium text-gray-900 dark:text-gray-300 mr-2 font-bold">
        Show Legend
      </span>
      <input
        type="checkbox"
        value=""
        className="sr-only peer"
        checked={showLegend}
        onChange={onToggle}
      />
      <div className="relative w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600"></div>
    </label>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\LogViewerSection.jsx -----

// src/features/timeline/components/LogViewerSection.jsx
import React from "react";
import { LineSelector, SDWTSelector, EqpSelector } from "@features/drilldown";
import PrcGroupSelector from "@features/drilldown/PrcGroupSelector";

export default function LogViewerSection({
  lineId,
  sdwtId,
  prcGroup,
  eqpId,
  setLine,
  setSdwt,
  setPrcGroup,
  setEqp,
}) {
  return (
    <section className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex flex-col">
      <h2 className="text-md font-bold text-slate-900 dark:text-white border-slate-200 dark:border-slate-700">
        📊 Log Viewer
      </h2>
      <div className="grid grid-cols-4 gap-2 mt-2">
        <LineSelector lineId={lineId} setLineId={setLine} />
        <SDWTSelector lineId={lineId} sdwtId={sdwtId} setSdwtId={setSdwt} />
        <PrcGroupSelector
          lineId={lineId}
          sdwtId={sdwtId}
          prcGroup={prcGroup}
          setPrcGroup={setPrcGroup}
        />
        <EqpSelector
          lineId={lineId}
          sdwtId={sdwtId}
          prcGroup={prcGroup}
          eqpId={eqpId}
          setEqpId={setEqp}
        />
      </div>
    </section>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\ShareButton.jsx -----

// src/features/timeline/components/ShareButton.jsx
import React, { useState } from "react";

export default function ShareButton() {
  const [showToast, setShowToast] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);

  const handleShare = async () => {
    const url = window.location.href;

    try {
      if (navigator.share) {
        await navigator.share({
          title: "EQP Timeline",
          text: "타임라인 링크를 공유합니다",
          url: url,
        });
      } else {
        await navigator.clipboard.writeText(url);
        setShowToast(true);
        setTimeout(() => setShowToast(false), 3000);
      }
    } catch (err) {
      console.error("URL 공유 실패:", err);
      const textArea = document.createElement("textarea");
      textArea.value = url;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
      setShowToast(true);
      setTimeout(() => setShowToast(false), 3000);
    }
  };

  return (
    <>
      {/* 부모 div에 relative position 추가 */}
      <div className="relative inline-block">
        <svg
          onClick={handleShare}
          className="w-5 h-5 text-blue-600 hover:text-blue-700 transition-colors cursor-pointer"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          onMouseEnter={() => setShowTooltip(true)}
          onMouseLeave={() => setShowTooltip(false)}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
          />
        </svg>

        {/* 툴팁 */}
        {showTooltip && (
          <div className="absolute top-1/2 left-full transform -translate-y-1/2 ml-2 px-2 py-1 text-xs text-white bg-gray-800 rounded-md whitespace-nowrap pointer-events-none">
            URL 복사
            {/* 툴팁 화살표 추가 (선택사항) */}
            <div className="absolute top-1/2 right-full transform -translate-y-1/2 w-0 h-0 border-t-4 border-b-4 border-r-4 border-transparent border-r-gray-800"></div>
          </div>
        )}
      </div>

      {/* 토스트 메시지 */}
      {showToast && (
        <div className="fixed bottom-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg animate-fade-in z-50">
          URL이 클립보드에 복사되었습니다!
        </div>
      )}
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\TimelineBoard.jsx -----

import EqpTimeline from "./EqpTimeline";
import TipTimeline from "./TipTimeline";
import EventTimeline from "./EventTimeline";
import { useTimelineRange } from "../hooks/useTimelineRange";

export default function TimelineBoard({
  lineId,
  eqpId,
  showLegend,
  selectedTipGroups,
  // 새로 추가: 각 타임라인의 로그 데이터를 props로 받기
  eqpLogs = [],
  tipLogs = [],
  eventLogs = [],
}) {
  // 모든 로그를 합쳐서 범위 계산
  const allLogs = [...eqpLogs, ...tipLogs, ...eventLogs];
  const range = useTimelineRange(allLogs);

  return (
    <div className="w-full space-y-0">
      <EqpTimeline
        lineId={lineId}
        eqpId={eqpId}
        range={range}
        showLegend={showLegend}
        showTimeAxis={false}
        eqpLogs={eqpLogs} // 데이터를 props로 전달
      />

      <TipTimeline
        lineId={lineId}
        eqpId={eqpId}
        range={range}
        showLegend={showLegend}
        selectedTipGroups={selectedTipGroups}
        showTimeAxis={false}
        tipLogs={tipLogs} // 데이터를 props로 전달
      />

      <EventTimeline
        lineId={lineId}
        eqpId={eqpId}
        range={range}
        showLegend={showLegend}
        showTimeAxis={true}
        eventLogs={eventLogs} // 데이터를 props로 전달
      />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\TimelineSettings.jsx -----

import React from "react";
import LegendToggle from "./LegendToggle";
import TipFilterChips from "./TipFilterChips";

export default function TimelineSettings({
  showLegend,
  onLegendToggle,
  tipLogs,
  selectedTipGroups, // 추가
  onTipFilterChange,
}) {
  return (
    <div className="space-y-6">
      {/* Legend 설정 섹션 */}
      <div className="border-b border-gray-200 dark:border-gray-700 pb-6">
        <h3 className="text-sm font-semibold text-gray-900 dark:text-white mb-4">
          표시 설정
        </h3>
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <span className="text-xs text-gray-700 dark:text-gray-300">
              타임라인 범례 표시
            </span>
            <LegendToggle showLegend={showLegend} onToggle={onLegendToggle} />
          </div>
        </div>
      </div>

      {/* TIP 필터 섹션 */}
      {tipLogs && tipLogs.length > 0 && (
        <div>
          <h3 className="text-sm font-semibold text-gray-900 dark:text-white mb-4">
            TIP 그룹 필터
          </h3>
          <TipFilterChips
            tipLogs={tipLogs}
            selectedTipGroups={selectedTipGroups} // 추가
            onFilterChange={onTipFilterChange}
            inDrawer={true}
          />
        </div>
      )}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\TipFilterChips.jsx -----

import React, { useMemo, useState, useEffect } from "react";
import { XMarkIcon } from "@heroicons/react/20/solid";

export default function TipFilterChips({
  tipLogs,
  onFilterChange,
  inDrawer = false,
}) {
  const [selectedGroups, setSelectedGroups] = useState(new Set());
  const [showAll, setShowAll] = useState(false);
  const [isAllSelected, setIsAllSelected] = useState(true); // 초기값은 전체 선택

  // TIP 로그를 그룹별로 정리
  const tipGroups = useMemo(() => {
    const groupMap = new Map();

    tipLogs.forEach((log) => {
      const groupKey = `${log.process || "unknown"}_${log.step || "unknown"}_${
        log.ppid || "unknown"
      }`;
      if (!groupMap.has(groupKey)) {
        groupMap.set(groupKey, {
          key: groupKey,
          process: log.process || "unknown",
          step: log.step || "unknown",
          ppid: log.ppid || "unknown",
          count: 0,
        });
      }
      groupMap.get(groupKey).count++;
    });

    return Array.from(groupMap.values()).sort((a, b) => {
      if (a.process !== b.process) return a.process.localeCompare(b.process);
      if (a.step !== b.step) return a.step.localeCompare(b.step);
      return a.ppid.localeCompare(b.ppid);
    });
  }, [tipLogs]);

  // 표시할 그룹 (처음 5개 또는 전체)
  const displayGroups = showAll ? tipGroups : tipGroups.slice(0, 5);

  // 선택 상태가 변경될 때마다 부모 컴포넌트에 알림
  useEffect(() => {
    if (isAllSelected) {
      // 전체 선택 상태면 특별한 값 전달
      onFilterChange(["__ALL__"]);
    } else if (selectedGroups.size === 0) {
      // 아무것도 선택되지 않으면 빈 배열
      onFilterChange([]);
    } else {
      // 선택된 그룹들만 전달
      onFilterChange(Array.from(selectedGroups));
    }
  }, [selectedGroups, isAllSelected, onFilterChange]);

  // 그룹 선택/해제 핸들러
  const handleGroupToggle = (groupKey) => {
    if (isAllSelected) {
      // 전체 선택 상태에서 하나를 클릭하면, 나머지를 모두 선택하고 클릭한 것만 해제
      const newSelected = new Set(tipGroups.map((g) => g.key));
      newSelected.delete(groupKey);
      setSelectedGroups(newSelected);
      setIsAllSelected(false);
    } else {
      const newSelected = new Set(selectedGroups);
      if (newSelected.has(groupKey)) {
        newSelected.delete(groupKey);
      } else {
        newSelected.add(groupKey);
      }

      // 모든 그룹이 선택되면 전체 선택 상태로 변경
      if (newSelected.size === tipGroups.length) {
        setIsAllSelected(true);
        setSelectedGroups(new Set());
      } else {
        setSelectedGroups(newSelected);
      }
    }
  };

  // 전체 선택/해제
  const handleSelectAll = () => {
    if (isAllSelected || selectedGroups.size === tipGroups.length) {
      // 전체 해제
      setSelectedGroups(new Set());
      setIsAllSelected(false);
    } else {
      // 전체 선택
      setSelectedGroups(new Set());
      setIsAllSelected(true);
    }
  };

  // 그룹이 선택되었는지 확인
  const isGroupSelected = (groupKey) => {
    if (isAllSelected) return true;
    return selectedGroups.has(groupKey);
  };

  return (
    <div
      className={
        inDrawer ? "" : "bg-white dark:bg-slate-800 rounded-lg p-3 mb-2"
      }
    >
      <div className="flex items-center justify-between mb-2">
        {!inDrawer && (
          <h4 className="text-xs font-semibold text-slate-900 dark:text-white">
            TIP 그룹 필터
          </h4>
        )}
        <div
          className={`flex items-center gap-2 ${
            inDrawer ? "w-full justify-end" : ""
          }`}
        >
          <button
            onClick={handleSelectAll}
            className="text-xs text-blue-700 dark:text-blue-300 hover:underline dark:hover:text-blue-300"
          >
            {isAllSelected || selectedGroups.size === tipGroups.length
              ? "전체 해제"
              : "전체 선택"}
          </button>
        </div>
      </div>

      <div className="flex flex-wrap gap-1.5">
        {displayGroups.map((group) => {
          const isSelected = isGroupSelected(group.key);
          return (
            <button
              key={group.key}
              onClick={() => handleGroupToggle(group.key)}
              className={`
                inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium
                transition-all duration-200 border
                ${
                  isSelected
                    ? "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 border-blue-300 dark:border-blue-700"
                    : "bg-gray-100 dark:bg-gray-700 text-gray-500 dark:text-gray-400 border-gray-300 dark:border-gray-600 opacity-60"
                }
                hover:opacity-100
              `}
              title={`Process: ${group.process} | Step: ${group.step} | PPID: ${group.ppid}`}
            >
              <span className="font-semibold">{group.ppid}</span>
              <span className="text-[10px] text-gray-600 dark:text-gray-400">
                ({group.count})
              </span>
              {isSelected && <XMarkIcon className="w-3 h-3 ml-0.5" />}
            </button>
          );
        })}

        {!showAll && tipGroups.length > 5 && (
          <button
            onClick={() => setShowAll(true)}
            className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium
              bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300
              hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
          >
            +{tipGroups.length - 5} 더보기
          </button>
        )}
      </div>

      {!isAllSelected && selectedGroups.size === 0 && (
        <div className="mt-2 text-xs text-slate-600 dark:text-slate-400">
          PPID 선택하세요
        </div>
      )}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\components\TipTimeline.jsx -----

import React, { useMemo } from "react";
import BaseTimeline from "./BaseTimeline";
import { processData } from "../utils/timelineUtils";
import { makeTipGroupLabel } from "../utils/groupLabel";

export default function TipTimeline({
  tipLogs = [], // 부모에서 전달받은 TIP 로그
  range,
  showLegend,
  selectedTipGroups = ["__ALL__"],
  showTimeAxis = true,
}) {
  // 필터링된 TIP 로그
  const filteredTipLogs = useMemo(() => {
    if (!tipLogs.length) return [];
    if (selectedTipGroups.includes("__ALL__")) return tipLogs;

    return tipLogs.filter((log) => {
      const groupKey = `${log.process || "unknown"}_${log.step || "unknown"}_${
        log.ppid || "unknown"
      }`;
      return selectedTipGroups.includes(groupKey);
    });
  }, [tipLogs, selectedTipGroups]);

  // 동적 그룹 생성
  const { groups, items } = useMemo(() => {
    const groupMap = new Map();
    const processedItems = [];

    filteredTipLogs.forEach((log) => {
      const groupKey = `TIP_${log.process || "unknown"}_${
        log.step || "unknown"
      }_${log.ppid || "unknown"}`;

      if (!groupMap.has(groupKey)) {
        groupMap.set(groupKey, {
          id: groupKey,
          content: makeTipGroupLabel(
            log.process,
            log.step,
            log.ppid,
            showLegend
          ),
          className: showLegend
            ? "custom-group-label tip-group legend-mode"
            : "custom-group-label tip-group",
          order: 100 + groupMap.size,
          title: `Process: ${log.process || "N/A"} | Step: ${
            log.step || "N/A"
          } | PPID: ${log.ppid || "N/A"}`,
        });
      }
    });

    // 각 그룹별로 아이템 생성
    const groupedLogs = new Map();
    filteredTipLogs.forEach((log) => {
      const groupKey = `TIP_${log.process || "unknown"}_${
        log.step || "unknown"
      }_${log.ppid || "unknown"}`;

      if (!groupedLogs.has(groupKey)) {
        groupedLogs.set(groupKey, []);
      }
      groupedLogs.get(groupKey).push(log);
    });

    groupedLogs.forEach((logs, groupKey) => {
      const items = processData("TIP", logs, true);
      items.forEach((item) => {
        processedItems.push({ ...item, group: groupKey });
      });
    });

    return {
      groups: Array.from(groupMap.values()).sort((a, b) => a.order - b.order),
      items: processedItems,
    };
  }, [filteredTipLogs, showLegend]);

  const options = useMemo(
    () => ({
      stack: false,
      min: range.min,
      max: range.max,
      zoomMin: 60 * 60 * 1000,
      groupHeightMode: "auto",
      maxHeight: 400,
      verticalScroll: true,
    }),
    [range]
  );

  // TIP 로그가 없거나 필터링 결과가 없을 때
  if (tipLogs.length === 0 || groups.length === 0) {
    return (
      <div className="timeline-container relative">
        <div className="flex items-center justify-between mb-1">
          <h3 className="text-sm font-semibold text-slate-600 dark:text-slate-300">
            🔧 TIP 로그
          </h3>
          <span className="text-xs text-slate-500">
            {tipLogs.length === 0 ? "로그 없음" : "선택된 그룹 없음"}
          </span>
        </div>
        <div className="h-20 flex items-center justify-center bg-slate-50 dark:bg-slate-800 rounded-lg">
          <p className="text-sm text-slate-500 dark:text-slate-400">
            {tipLogs.length === 0
              ? "TIP 로그가 없습니다"
              : "표시할 TIP 그룹을 선택하세요"}
          </p>
        </div>
      </div>
    );
  }

  return (
    <BaseTimeline
      groups={groups}
      items={items}
      options={options}
      title="🔧 TIP 로그"
      showTimeAxis={showTimeAxis}
      headerExtra={
        <span className="text-xs text-slate-500">
          {groups.length}개 그룹, {filteredTipLogs.length}개 로그
        </span>
      }
    />
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\constants\index.js -----

export const DATA_TYPES = {
  EQP: "EQP",
  TIP: "TIP",
  RACB: "RACB",
  CTTTM: "CTTTM",
  JIRA: "JIRA",
};

export const DEFAULT_TYPE_FILTERS = {
  [DATA_TYPES.EQP]: true,
  [DATA_TYPES.TIP]: true,
  [DATA_TYPES.RACB]: true,
  [DATA_TYPES.CTTTM]: true,
  [DATA_TYPES.JIRA]: true,
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\index.js -----

export { useVisTimeline } from "./useVisTimeline";
export { useTimelineRange } from "./useTimelineRange";
export { useEqpLogs } from "./useEqpLogs";
export { useEventLogs } from "./useEventLogs";
export { useTipLogs } from "./useTipLogs";
export { useUrlValidation } from "./useUrlValidation";
export { useUrlSync } from "./useUrlSync";


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useEqpLogs.js -----

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@shared/services/api/client";

export const useEqpLogs = (lineId, eqpId) => {
  return useQuery({
    queryKey: ["logs", "eqp", lineId, eqpId],
    queryFn: () =>
      apiClient("/logs/eqp", {
        params: { lineId, eqpId },
      }),
    enabled: !!lineId && !!eqpId,
    staleTime: 1000 * 60 * 5,
  });
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useEventLogs.js -----

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@shared/services/api/client";

export const useEventLogs = (lineId, eqpId) => {
  return useQuery({
    queryKey: ["logs", "event", lineId, eqpId],
    queryFn: () =>
      apiClient("/logs/event", {
        params: { lineId, eqpId },
      }),
    enabled: !!lineId && !!eqpId,
    staleTime: 1000 * 60 * 5,
  });
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useTimelineRange.js -----

import { useMemo } from "react";
import { calcRange, addBuffer } from "../utils/timelineUtils";

/**
 * 로그 배열을 받아서 타임라인 범위를 계산하는 훅
 * @param {Array} logs - 모든 로그 데이터가 합쳐진 배열
 */
export function useTimelineRange(logs = []) {
  const range = useMemo(() => {
    if (logs.length === 0) {
      // 로그가 없을 때 기본 범위 (오늘 하루)
      const today = new Date();
      const startOfToday = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate()
      );
      const endOfToday = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate() + 1
      );
      return addBuffer(startOfToday.getTime(), endOfToday.getTime());
    }

    const { min, max } = calcRange(logs);
    return addBuffer(min.getTime(), max.getTime());
  }, [logs]);

  return range;
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useTipLogs.js -----

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@shared/services/api/client";

export const useTipLogs = (lineId, eqpId) => {
  return useQuery({
    queryKey: ["logs", "tip", lineId, eqpId],
    queryFn: () =>
      apiClient("/logs/tip", {
        params: { lineId, eqpId },
      }),
    enabled: !!lineId && !!eqpId,
    staleTime: 1000 * 60 * 5,
  });
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useUrlSync.js -----

// src/features/timeline/hooks/useUrlSync.js
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";

export function useUrlSync(lineId, eqpId, isValidating, isUrlInitialized) {
  const navigate = useNavigate();

  useEffect(() => {
    if (isValidating || !isUrlInitialized) return;

    const currentPath = window.location.pathname;
    const isParamRoute =
      currentPath.includes("/timeline/") && currentPath.split("/").length > 3;

    if (lineId && eqpId) {
      const newPath = `/timeline/${lineId}/${eqpId}`;
      if (currentPath !== newPath) {
        navigate(newPath, { replace: true });
      }
    } else {
      if (isParamRoute) {
        navigate("/timeline", { replace: true });
      }
    }
  }, [lineId, eqpId, navigate, isValidating, isUrlInitialized]);
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useUrlValidation.js -----

// src/features/timeline/hooks/useUrlValidation.js

import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { timelineApi } from "@/features/timeline/api/timelineApi";

export function useUrlValidation(
  params,
  lineId,
  eqpId,
  setLine,
  setSdwt,
  setPrcGroup,
  setEqp
) {
  const [isValidating, setIsValidating] = useState(false);
  const [validationError, setValidationError] = useState(null);
  const [isUrlInitialized, setIsUrlInitialized] = useState(false);

  const navigate = useNavigate();

  useEffect(() => {
    const validateAndSetParams = async () => {
      if (params.lineId && params.eqpId) {
        setIsValidating(true);
        setValidationError(null);
        setIsUrlInitialized(true);

        try {
          const eqpInfo = await timelineApi.fetchEquipmentInfo(
            params.lineId,
            params.eqpId
          );

          // 백엔드에서 이미 유효성 검증이 완료됨
          if (!eqpInfo) {
            setValidationError("유효하지 않은 Line ID 또는 EQP ID입니다.");
            setTimeout(() => navigate("/timeline"), 1500);
            return;
          }

          // 상태 업데이트
          setLine(params.lineId);
          setSdwt(eqpInfo.sdwtId);
          setPrcGroup(eqpInfo.prcGroup);
          setEqp(params.eqpId);
        } catch {
          setValidationError("데이터 검증 중 오류가 발생했습니다.");
          setTimeout(() => navigate("/timeline"), 1500);
        } finally {
          setIsValidating(false);
        }
      } else {
        setIsUrlInitialized(true);
      }
    };

    if (!isUrlInitialized) {
      validateAndSetParams();
    }
  }, [
    params.lineId,
    params.eqpId,
    isUrlInitialized,
    navigate,
    setLine,
    setSdwt,
    setPrcGroup,
    setEqp,
  ]);

  return { isValidating, validationError, isUrlInitialized };
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\hooks\useVisTimeline.js -----

import { useEffect, useRef } from "react";
import { DataSet } from "vis-data";
import { useSelectionStore } from "@shared/store";

/**
 * vis-timeline 생성을 공통 처리하는 훅
 * @param {Object} params
 * @param {React.RefObject} params.containerRef - 타임라인 DOM을 가리키는 ref
 * @param {Array} params.groups - vis-timeline 그룹 배열
 * @param {Array} params.items - vis-timeline 아이템 배열
 * @param {Object} params.options - vis-timeline 옵션
 */
export function useVisTimeline({ containerRef, groups, items, options }) {
  // vis-timeline 인스턴스 보관용 ref
  const tlRef = useRef(null);
  // 전역 스토어에서 타임라인 풀 관리 및 선택 상태 제어 함수 사용
  const { register, unregister, syncRange, setSelectedRow, selectedRow } =
    useSelectionStore();

  // 1. 컴포넌트 마운트 시 한 번만 인스턴스 생성
  useEffect(() => {
    let mounted = true;
    (async () => {
      const { Timeline } = await import("vis-timeline/standalone");
      if (!mounted || !containerRef.current) return;

      // 초기 아이템/그룹으로 타임라인을 생성
      const dataset = new DataSet(items);
      tlRef.current = new Timeline(
        containerRef.current,
        dataset,
        groups,
        options
      );

      register(tlRef.current);

      // 다른 타임라인과 범위 동기화
      tlRef.current.on("rangechange", ({ start, end }) =>
        syncRange(tlRef.current, start, end)
      );

      // 아이템 선택 시 전역 상태에 반영
      tlRef.current.on("select", ({ items }) => {
        const currentSelected = useSelectionStore.getState().selectedRow;
        if (items && items.length > 0) {
          if (String(currentSelected) === String(items[0])) {
            setSelectedRow(null, "timeline");
            tlRef.current.setSelection([]);
          } else {
            setSelectedRow(items[0], "timeline");
          }
        } else {
          setSelectedRow(null, "timeline");
        }
      });
    })();

    return () => {
      mounted = false;
      if (tlRef.current) {
        // 스토어와 연결 해제 후 인스턴스 파괴
        unregister(tlRef.current);
        tlRef.current.destroy();
      }
    };
  }, []);

  // 2. 아이템 배열이 바뀌면 교체
  useEffect(() => {
    if (tlRef.current) {
      tlRef.current.setItems(new DataSet(items));
    }
  }, [items]);

  // 3. 그룹 정보 변경 시 갱신 (visibility 처리 포함)
  useEffect(() => {
    if (tlRef.current && groups) {
      // vis-timeline의 그룹 visibility 설정
      const updatedGroups = groups.map((g) => ({
        ...g,
        visible: g.visible !== false,
      }));
      tlRef.current.setGroups(updatedGroups);
    }
  }, [groups]);

  // 4. 옵션 변경 시 범위 업데이트 (동기화 개선)
  useEffect(() => {
    if (tlRef.current && options.min && options.max) {
      tlRef.current.setWindow(options.min, options.max, { animation: false });
    }
  }, [options.min, options.max]);

  // 5. 외부에서 선택된 행을 타임라인에 반영
  useEffect(() => {
    if (tlRef.current) {
      if (selectedRow && tlRef.current.itemsData.get(selectedRow)) {
        tlRef.current.setSelection([selectedRow]);
      } else {
        tlRef.current.setSelection([]);
      }
    }
  }, [selectedRow]);

  return tlRef;
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\pages\TimelinePage.jsx -----

import React, { useState, useMemo } from "react";
import { useParams } from "react-router-dom";
import { AdjustmentsHorizontalIcon } from "@heroicons/react/24/outline";
import { useSelectionStore } from "@shared/store";
import { useUrlValidation } from "@features/timeline/hooks/useUrlValidation";
import { useUrlSync } from "@features/timeline/hooks/useUrlSync";
import { transformLogsToTableData } from "@features/timeline/utils/dataTransformers";
import { DEFAULT_TYPE_FILTERS } from "@features/timeline/constants";
import LogViewerSection from "@features/timeline/components/LogViewerSection";
import DataLogSection from "@features/timeline/components/DataLogSection";
import ShareButton from "@features/timeline/components/ShareButton";
import { TimelineBoard } from "@features/timeline";
import LogDetailSection from "@features/table/components/LogDetailSection";
import { LoadingSpinner } from "@shared/components";
import { Drawer } from "@shared/components";
import TimelineSettings from "@features/timeline/components/TimelineSettings";
// 각 타임라인의 개별 훅들을 직접 import
import { useEqpLogs } from "@features/timeline/hooks/useEqpLogs";
import { useTipLogs } from "@features/timeline/hooks/useTipLogs";
import { useEventLogs } from "@features/timeline/hooks/useEventLogs";

export default function TimelinePage() {
  const params = useParams();
  const {
    lineId,
    sdwtId,
    prcGroup,
    eqpId,
    setLine,
    setSdwt,
    setPrcGroup,
    setEqp,
    selectedRow,
  } = useSelectionStore();

  // URL 검증
  const { isValidating, validationError, isUrlInitialized } = useUrlValidation(
    params,
    lineId,
    eqpId,
    setLine,
    setSdwt,
    setPrcGroup,
    setEqp
  );

  // URL 동기화
  useUrlSync(lineId, eqpId, isValidating, isUrlInitialized);

  // 각 타임라인의 로그 데이터를 개별적으로 가져오기
  const enabled = Boolean(lineId && eqpId);
  const { data: eqpLogs = [], isLoading: eqpLoading } = useEqpLogs(
    lineId,
    eqpId
  );
  const { data: tipLogs = [], isLoading: tipLoading } = useTipLogs(
    lineId,
    eqpId
  );
  const { data: eventLogs = [], isLoading: eventLoading } = useEventLogs(
    lineId,
    eqpId
  );

  // 로딩 상태 계산
  const logsLoading = eqpLoading || tipLoading || eventLoading;

  // 모든 로그 데이터를 하나로 합치기
  const mergedLogs = useMemo(() => {
    if (!enabled) return [];

    // 모든 로그를 배열로 합치기
    const allLogs = [...eqpLogs, ...tipLogs, ...eventLogs];

    // 시간순으로 정렬 (최신순)
    return allLogs.sort(
      (a, b) =>
        new Date(b.eventTime).getTime() - new Date(a.eventTime).getTime()
    );
  }, [eqpLogs, tipLogs, eventLogs, enabled]);

  // 로컬 상태
  const [typeFilters, setTypeFilters] = useState(DEFAULT_TYPE_FILTERS);
  const [showLegend, setShowLegend] = useState(false);
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [selectedTipGroups, setSelectedTipGroups] = useState(["__ALL__"]);

  // 필터 핸들러
  const handleFilter = (e) =>
    setTypeFilters((prev) => ({ ...prev, [e.target.name]: e.target.checked }));

  // 테이블 데이터 변환 (병합된 로그 사용)
  const tableData = useMemo(
    () =>
      enabled && !logsLoading
        ? transformLogsToTableData(mergedLogs, typeFilters)
        : [],
    [mergedLogs, logsLoading, enabled, typeFilters]
  );

  // 선택된 로그 (병합된 로그에서 찾기)
  const selectedLog = useMemo(
    () => mergedLogs.find((log) => String(log.id) === String(selectedRow)),
    [mergedLogs, selectedRow]
  );

  // TIP 로그만 필터링 (Settings Drawer용)
  const filteredTipLogs = useMemo(
    () => mergedLogs.filter((log) => log.logType === "TIP"),
    [mergedLogs]
  );

  // 검증 중일 때 로딩 표시
  if (isValidating) {
    return (
      <div className="flex items-center justify-center h-[80vh]">
        <LoadingSpinner />
      </div>
    );
  }

  // 에러 상황 체크 (개별 에러는 각 훅에서 처리됨)

  // 검증 에러 표시
  if (validationError) {
    return (
      <div className="flex items-center justify-center h-[80vh]">
        <div className="text-center">
          <p className="text-red-500 mb-2">{validationError}</p>
          <p className="text-gray-500">잠시 후 메인 페이지로 이동합니다...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col lg:flex-row h-[calc(100vh-85px)] gap-2 mt-3">
      {/* 왼쪽 패널 */}
      <div className="flex flex-col h-full min-h-0 lg:w-[35%] gap-2">
        <LogViewerSection
          lineId={lineId}
          sdwtId={sdwtId}
          prcGroup={prcGroup}
          eqpId={eqpId}
          setLine={setLine}
          setSdwt={setSdwt}
          setPrcGroup={setPrcGroup}
          setEqp={setEqp}
        />

        <div className="flex-1 min-h-0 flex flex-col gap-2">
          <DataLogSection
            eqpId={eqpId}
            logsLoading={logsLoading}
            tableData={tableData}
            typeFilters={typeFilters}
            handleFilter={handleFilter}
          />

          <section
            className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex-[1] min-h-0 flex flex-col overflow-auto"
            style={{ minHeight: 180, maxHeight: 320 }}
          >
            <h2 className="text-md font-bold text-slate-900 dark:text-white border-slate-200 dark:border-slate-700 pb-1">
              📝 Log Detail
            </h2>
            <hr className="my-1 border-slate-300 dark:border-slate-600" />
            <LogDetailSection log={selectedLog} />
          </section>
        </div>
      </div>

      {/* 오른쪽 타임라인 패널 */}
      <div className="lg:w-[65%] h-full overflow-hidden bg-white dark:bg-slate-800 shadow rounded-xl p-4">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <h2 className="text-md font-bold text-slate-900 dark:text-white">
              📊 Timeline
            </h2>
            {lineId && eqpId && <ShareButton />}
          </div>

          {/* 설정 버튼 - EQP가 선택되었을 때만 표시 */}
          {eqpId && !logsLoading && (
            <button
              onClick={() => setIsDrawerOpen(true)}
              className="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              <AdjustmentsHorizontalIcon className="h-4 w-4" />
              설정
            </button>
          )}
        </div>

        <hr className="border-slate-300 dark:border-slate-600" />

        {!eqpId && !logsLoading ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-center text-slate-600 dark:text-slate-400">
              EQP를 선택하세요.
            </p>
          </div>
        ) : logsLoading ? (
          <div className="flex items-center justify-center h-full">
            <LoadingSpinner />
          </div>
        ) : (
          <div className="mt-4">
            <TimelineBoard
              lineId={lineId}
              eqpId={eqpId}
              showLegend={showLegend}
              selectedTipGroups={selectedTipGroups}
              eqpLogs={eqpLogs}
              tipLogs={tipLogs}
              eventLogs={eventLogs}
            />
          </div>
        )}
      </div>

      {/* Settings Drawer */}
      <Drawer
        isOpen={isDrawerOpen}
        onClose={() => setIsDrawerOpen(false)}
        title="타임라인 설정"
      >
        <TimelineSettings
          showLegend={showLegend}
          onLegendToggle={() => setShowLegend((v) => !v)}
          tipLogs={filteredTipLogs} // 병합된 로그에서 필터링된 TIP 로그 전달
          selectedTipGroups={selectedTipGroups}
          onTipFilterChange={setSelectedTipGroups}
        />
      </Drawer>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\styles\timeline.css -----

/* ─────────────────────────────────────────────────────────────────────────
   vis-timeline 커스터마이징
───────────────────────────────────────────────────────────────────────── */

.timeline-container { margin-bottom: 16px; }

/* 공통 아이템 */
.vis-item {
  border: 1px solid transparent;
  color: #1e293b;
  border-radius: 0 !important;
  margin-right: -1px;
  box-shadow: none !important;
  pointer-events: all !important;
}
.dark .vis-item { color: #f1f5f9; }

/* 아이템 내부 content 텍스트 스타일 */
.vis-item .vis-item-content {
  font-size: 11px !important;  /* 폰트 크기 조절 */
  font-weight: 500 !important;  /* 약간 굵게 */
  padding: 2px 4px !important;  /* 내부 여백 */
  white-space: nowrap !important;  /* 줄바꿈 방지 */
  overflow: hidden !important;
  text-overflow: ellipsis !important;  /* 긴 텍스트는 ... 처리 */
}

/* 상태 색상 */
.vis-item.bg-red-500    { background-color: #ef4444; border-color: #dc2626; }
.vis-item.bg-green-500  { background-color: #22c55e; border-color: #16a34a; }
.vis-item.bg-blue-500   { background-color: #3b82f6; border-color: #2563eb; }
.vis-item.bg-yellow-500 { background-color: #eab308; border-color: #ca8a04; }
.vis-item.bg-gray-300   { background-color: #d1d5db; border-color: #9ca3af; }
/* 600 계열 */
.vis-item.bg-red-600    { background-color: #dc2626; border-color: #b91c1c; }
.vis-item.bg-blue-600   { background-color: #2563eb; border-color: #1d4ed8; }
.vis-item.bg-yellow-600 { background-color: #ca8a04; border-color: #a16207; }
.vis-item.bg-green-600  { background-color: #16a34a; border-color: #15803d; }
.vis-item.bg-amber-600  { background-color: #d97706; border-color: #b45309; }
.vis-item.bg-purple-600 { background-color: #9333ea; border-color: #7c3aed; }
.vis-item.bg-gray-600   { background-color: #4b5563; border-color: #374151; }
.vis-item.bg-orange-600 { background-color: #ea580c; border-color: #c2410c; }

/* 선택 아이템 */
.vis-item.vis-selected {
  outline: 2px dashed #fb923c !important;  
  outline-offset: -2px !important;              
  background-color: rgba(251, 146, 60, 0.2) !important; 
  filter: brightness(1.1) !important;
  z-index: 10 !important;
}

/* 레인지/포인트 */
.vis-item.vis-range { pointer-events: all !important; min-height: 20px !important; }
.vis-item.vis-point { pointer-events: all !important; }

/* 시간축 텍스트 */
.vis-time-axis .vis-text,
.vis-time-axis .vis-label { font-size: 12px !important; color: #334155; }
.dark .vis-time-axis .vis-text,
.dark .vis-time-axis .vis-label { color: #f1f5f9 !important; }

/* 그룹 라벨 */
.vis-label.custom-group-label {
  color: #334155;
  font-size: 12px !important;
  width: 150px !important;
  min-width: 150px !important;
  max-width: 150px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.dark .vis-label.custom-group-label {
  color: #f1f5f9 !important;
  font-size: 12px !important;
}

/* 테이블 스크롤바 */
.table-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
.table-scroll::-webkit-scrollbar-track { background: #ffffff; border-radius: 10px; }
.table-scroll::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; border: 1px solid #e2e8f0; }
.dark .table-scroll::-webkit-scrollbar-track { background: #1e293b; }
.dark .table-scroll::-webkit-scrollbar-thumb { background: #475569; border: 1px solid #1e293b; }
.dark .table-scroll::-webkit-scrollbar-thumb:hover { background: #64748b; }

/* react-window & 가상 스크롤 스크롤바 스타일 */
.scrollbar-thin {
  scrollbar-width: thin;
  scrollbar-color: #94a3b8 #f1f5f9;
  /* 하드웨어 가속 */
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}
.dark .scrollbar-thin {
  scrollbar-color: #475569 #1e293b;
}
.scrollbar-thin::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
.scrollbar-thin::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}
.scrollbar-thin::-webkit-scrollbar-thumb {
  background: #94a3b8;
  border-radius: 4px;
}
.scrollbar-thin::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}
.dark .scrollbar-thin::-webkit-scrollbar-track {
  background: #1e293b;
}
.dark .scrollbar-thin::-webkit-scrollbar-thumb {
  background: #475569;
}
.dark .scrollbar-thin::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

/* 그룹 라벨에 legend-mode 클래스가 추가됐을 때만 폰트 크기를 12px로 */
.vis-label.legend-mode {
  font-size: 12px !important;
  font-weight: normal !important;
  letter-spacing: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 240px !important;
  min-width: 240px !important;
  max-width: 240px !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 !important;
}

/* 간단한 TIP 그룹 라벨 (PPID만 표시) */
.tip-group-label-simple {
  font-size: 12px;
  font-weight: 600;
  color: #3b82f6;
  text-align: center;
}
.dark .tip-group-label-simple {
  color: #60a5fa;
}

/* TIP 그룹 스타일 */
.vis-label.tip-group {
  background-color: rgba(59, 130, 246, 0.05);
  border-left: 3px solid #3b82f6;
}
.dark .vis-label.tip-group {
  background-color: rgba(59, 130, 246, 0.1);
}
/* TIP 그룹 hover 효과 */
.vis-label.tip-group:hover {
  background-color: rgba(59, 130, 246, 0.15);
}
.dark .vis-label.tip-group:hover {
  background-color: rgba(59, 130, 246, 0.25);
}

/* 툴팁 스타일 개선 */
.vis-tooltip {
  background-color: rgba(0, 0, 0, 0.9) !important;
  color: white !important;
  font-size: 11px !important;
  padding: 8px 12px !important;
  border-radius: 6px !important;
  white-space: nowrap !important;
}

/* x축이 없는 타임라인 스타일 */
.no-time-axis .vis-panel.vis-bottom {
  display: none !important;
}


/* 타임라인 간격 조정 (x축이 없으면 간격을 줄임) */
.timeline-container.no-time-axis {
  margin-bottom: 5px !important;
}

/* 마지막 타임라인은 정상 간격 유지 */
.timeline-container:last-child {
  margin-bottom: 16px !important;
}



/* 컴팩트 모드 */
.compact-timeline .vis-group {
  min-height: 20px !important;
  padding: 2px 0 !important;
}



----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\utils\dataTransformers.js -----

// src/features/timeline/utils/dataTransformers.js
import { formatDateTime } from "./dateUtils";

export function groupLogsByType(logs) {
  const groups = { EQP: [], TIP: [], RACB: [], CTTTM: [], JIRA: [] };
  logs.forEach((log) => {
    if (groups[log.logType]) {
      groups[log.logType].push(log);
    }
  });
  return groups;
}

export function transformLogsToTableData(logs, typeFilters) {
  const transformed = logs
    .filter((log) => typeFilters[log.logType])
    .map((log) => {
      const row = {
        id: log.id,
        timestamp: new Date(log.eventTime).getTime(),
        displayTimestamp: formatDateTime(log.eventTime),
        logType: log.logType,
        info1: log.eventType,
        info2: log.operator || "-",
        duration: "-", // duration은 더 이상 계산하지 않음
        url: log.url || null,
      };

      // TIP 로그인 경우 process/step 정보 추가 표시
      if (log.logType === "TIP" && (log.process || log.step || log.ppid)) {
        row.info1 = `${log.eventType} (${log.process || "N/A"}/${
          log.step || "N/A"
        })`;
      }

      return row;
    })
    .sort((a, b) => b.timestamp - a.timestamp);

  return transformed;
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\utils\dateUtils.js -----

/**
 * Format a Date (or date-like value) as 'YY/MM/DD HH:mm'.
 * Returns the input unchanged if it cannot be parsed.
 *
 * @param {Date|string|number} date - value convertible to Date
 * @returns {string} formatted date string
 */
export function formatDateTime(date) {
  const d = new Date(date);
  if (Number.isNaN(d.getTime())) return date;
  const yy = String(d.getFullYear()).slice(-2);
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const mi = String(d.getMinutes()).padStart(2, "0");
  return `${yy}/${mm}/${dd} ${hh}:${mi}`;
}



----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\utils\groupLabel.js -----

import { groupConfig } from "./timelineMeta";

export function makeGroupLabel(type, title, showLegend) {
  if (!showLegend) {
    return `<div style="width:240px">${title}</div>`;
  }
  const EMOJI = {
    RUN: "🟦RUN ",
    IDLE: "🟨IDLE ",
    PM: "🟩PM ",
    DOWN: "🟥DOWN ",
    OPEN: "🟦OPEN ",
    CLOSE: "🟥CLOSE ",
    ALARM: "🟥ALARM ",
    WARN: "🟧WARN ",
    TTM_FAIL: "🟥TTM_FAIL ",
    TTM_WARN: "🟨TTM_WARN ",
    ISSUED: "🟦ISSUED ",
    CLOSED: "🟪CLOSED ",
  };
  const config = groupConfig[type];
  if (!config) return `<div style="width:240px"></div>`;
  const legendHtml = Object.keys(config.stateColors)
    .map((state) => `<span>${EMOJI[state] || "▪️"}</span>`)
    .join(" ");
  return `<div style="width:240px;">${legendHtml}</div>`;
}

export function makeTipGroupLabel(process, step, ppid, showLegend) {
  // PPID만 표시하도록 수정
  const displayText = `<div class="tip-group-label-simple">${
    ppid || "N/A"
  }</div>`;

  if (!showLegend) {
    return `<div style="width:240px">${displayText}</div>`;
  }

  // Legend 모드일 때는 OPEN/CLOSE 범례 표시
  const legendHtml = `<span>🟦OPEN </span><span>🟥CLOSE </span>`;
  return `<div style="width:240px;">${legendHtml}</div>`;
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\utils\timelineMeta.js -----

/**
 * 각 로그 타입(logType)별 컬러 매핑
 * Tailwind 색상 클래스로 작성 (timeline.css @apply 로 색 지정)
 */
export const groupConfig = {
  EQP: {
    stateColors: {
      RUN: "bg-blue-600 border-blue-700",
      IDLE: "bg-yellow-600 border-yellow-700",
      PM: "bg-green-600 border-green-700",
      DOWN: "bg-red-600 border-red-700",
    },
  },
  TIP: {
    stateColors: {
      OPEN: "bg-blue-600 border-blue-700",
      CLOSE: "bg-red-600 border-red-700",
    },
  },
  RACB: {
    stateColors: {
      ALARM: "bg-red-600 border-red-700",
      WARN: "bg-amber-600 border-amber-700",
    },
  },
  CTTTM: {
    stateColors: {
      TTM_FAIL: "bg-red-600 border-red-700",
      TTM_WARN: "bg-yellow-600 border-yellow-700",
    },
  },
  JIRA: {
    stateColors: {
      ISSUED: "bg-blue-600 border-blue-700",
      CLOSED: "bg-purple-600 border-purple-700",
    },
  },
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\utils\timelineUtils.js -----

// 미사용 함수 제거하고 필요한 것만 남김
import { groupConfig } from "./timelineMeta";

/** ➜ vis-timeline 아이템 변환 */
export const processData = (logType, data, makeRangeContinuous = false) => {
  const cfg = groupConfig[logType];
  if (!cfg) return [];

  // 데이터를 eventTime 순으로 정렬
  const sortedData = data
    .filter((l) => l && l.eventTime)
    .sort((a, b) => new Date(a.eventTime) - new Date(b.eventTime));

  return sortedData.map((l, index) => {
    const start = new Date(l.eventTime);
    let end = start; // 기본값은 point 형태
    let isRange = false;

    // makeRangeContinuous가 true인 경우 range로 만들기
    if (makeRangeContinuous) {
      if (index < sortedData.length - 1) {
        // 다음 로그의 eventTime을 현재 로그의 endTime으로 설정
        end = new Date(sortedData[index + 1].eventTime);
      } else {
        // 마지막 로그인 경우, 오늘 00:00:00으로 설정
        const today = new Date(start);
        end = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate() + 1,
          0,
          0,
          0,
          0
        );
      }
      isRange = true;
    }

    const colorCls = cfg.stateColors[l.eventType] || "bg-gray-300";

    // 폰트 크기를 logType에 따라 다르게 설정
    const fontSize =
      {
        EQP: "12px",
        TIP: "11px",
        CTTTM: "10px",
        RACB: "10px",
        JIRA: "10px",
      }[logType] || "11px";

    return {
      id: l.id,
      group: logType,
      content: `<span style="font-size: ${fontSize}; font-weight: 500;">${
        l.eventType || ""
      }</span>`,
      start,
      end,
      type: isRange ? "range" : "point",
      className: colorCls,
      title: [
        l.comment,
        l.operator ? `👤 ${l.operator}` : null,
        l.url ? `🔗 ${l.url}` : null,
      ]
        .filter(Boolean)
        .join("\n"),
    };
  });
};

/** 전체 로그 범위 계산 */
export const calcRange = (logs) => {
  if (!logs || logs.length === 0) {
    // 로그가 없을 때 기본값
    const now = new Date();
    return {
      min: new Date(now.getFullYear(), now.getMonth(), now.getDate()),
      max: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1),
    };
  }

  // eventTime이 있는 로그만 필터링
  const validLogs = logs.filter((log) => log && log.eventTime);

  if (validLogs.length === 0) {
    const now = new Date();
    return {
      min: new Date(now.getFullYear(), now.getMonth(), now.getDate()),
      max: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1),
    };
  }

  // 모든 시간을 추출 (eventTime과 endTime 모두 고려)
  const allTimes = [];

  validLogs.forEach((log) => {
    const eventTime = new Date(log.eventTime).getTime();
    if (!isNaN(eventTime)) {
      allTimes.push(eventTime);
    }

    // endTime도 있다면 포함
    if (log.endTime) {
      const endTime = new Date(log.endTime).getTime();
      if (!isNaN(endTime)) {
        allTimes.push(endTime);
      }
    }
  });

  if (allTimes.length === 0) {
    const now = new Date();
    return {
      min: new Date(now.getFullYear(), now.getMonth(), now.getDate()),
      max: new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1),
    };
  }

  const minTime = Math.min(...allTimes);
  const maxTime = Math.max(...allTimes);

  return {
    min: new Date(minTime),
    max: new Date(maxTime),
  };
};

/** 버퍼 추가 (줌 아웃을 위해 여유 공간 추가) */
export const addBuffer = (min, max) => {
  const range = max - min;
  const bufferRatio = 0.1; // 전체 범위의 10%를 버퍼로
  const buffer = Math.max(range * bufferRatio, 24 * 60 * 60 * 1000); // 최소 1일

  return {
    min: new Date(min - buffer),
    max: new Date(max + buffer),
  };
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\features\timeline\index.js -----

export * from "./api/timelineApi";
export { default as TimelineBoard } from "./components/TimelineBoard";
export { default as TimelinePage } from "./pages/TimelinePage";
export * from "./hooks";
import "./styles/timeline.css";


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\layouts\MainLayout\Navbar.jsx -----

import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import {
  Dialog,
  DialogPanel,
  Disclosure,
  DisclosureButton,
  DisclosurePanel,
  Popover,
  PopoverButton,
  PopoverGroup,
  PopoverPanel,
} from "@headlessui/react";
import {
  ArrowPathIcon,
  Bars3Icon,
  ChartPieIcon,
  CursorArrowRaysIcon,
  FingerPrintIcon,
  SquaresPlusIcon,
  XMarkIcon,
  SunIcon,
  MoonIcon,
} from "@heroicons/react/24/outline";
import {
  ChevronDownIcon,
  PhoneIcon,
  PlayCircleIcon,
} from "@heroicons/react/20/solid";

// "Product" 드롭다운에 사용될 예시 데이터
const products = [
  {
    name: "Analytics",
    description: "트래픽 분석",
    href: "#",
    icon: ChartPieIcon,
  },
  {
    name: "Engagement",
    description: "고객 소통",
    href: "#",
    icon: CursorArrowRaysIcon,
  },
  {
    name: "Security",
    description: "데이터 보안",
    href: "#",
    icon: FingerPrintIcon,
  },
  {
    name: "Integrations",
    description: "외부 연동",
    href: "#",
    icon: SquaresPlusIcon,
  },
  {
    name: "Automations",
    description: "자동화",
    href: "#",
    icon: ArrowPathIcon,
  },
];
const callsToAction = [
  { name: "Watch demo", href: "#", icon: PlayCircleIcon },
  { name: "Contact sales", href: "#", icon: PhoneIcon },
];

export default function Navbar() {
  // 모바일 메뉴와 다크모드 상태를 관리
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [darkMode, setDarkMode] = useState(false);

  // 컴포넌트가 처음 마운트될 때, localStorage나 OS 기본 테마를 기준으로 다크모드 설정을 결정
  useEffect(() => {
    const isDark =
      localStorage.theme === "dark" ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches);
    setDarkMode(isDark);
    if (isDark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, []);

  // 다크모드 토글 (버튼 클릭 시 실행)
  const toggleDarkMode = () => {
    // Tailwind 공식 권장 방식: classList.toggle 로 결과값을 그대로 사용
    const isDark = document.documentElement.classList.toggle("dark");
    setDarkMode(isDark);

    // 사용자가 '라이트' 모드를 선택한 경우 key 자체를 지워 두면
    // 다음 방문 시 OS 선호도(prefers-color-scheme)가 다시 적용됩니다.
    if (isDark) {
      localStorage.theme = "dark";
    } else {
      localStorage.removeItem("theme");
    }
  };

  return (
    // 상단 고정 네비게이션 바
    <header className="bg-white dark:bg-gray-800 shadow-md sticky top-0 z-50  h-15">
      <nav
        aria-label="Global"
        className="mx-auto flex max-w-7xl items-center justify-between p-5 lg:px-8 h-15"
      >
        {/* 로고: 메인 페이지로 이동 */}
        <div className="flex lg:flex-1">
          <Link to="/" className="-m-1.5 p-1.5">
            <span className="sr-only">Your Company</span>
            <img
              alt="Company Logo"
              src="https://tailwindcss.com/plus-assets/img/logos/158x48/transistor-logo-gray-900.svg"
              className="h-8 w-auto"
            />
          </Link>
        </div>
        {/* 모바일 메뉴 버튼 (작은 화면에서만 보임) */}
        <div className="flex lg:hidden">
          <button
            type="button"
            onClick={() => setMobileMenuOpen(true)}
            className="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700 dark:text-gray-300"
          >
            <span className="sr-only">Open main menu</span>
            <Bars3Icon aria-hidden="true" className="size-6" />
          </button>
        </div>
        {/* 데스크탑 메뉴: Product, Timeline 등 네비게이션 */}
        <PopoverGroup className="hidden lg:flex lg:gap-x-12">
          <Popover className="relative">
            <PopoverButton className="flex items-center gap-x-1 text-xs/6 font-semibold text-gray-900 dark:text-gray-100 focus:outline-none">
              Product
              <ChevronDownIcon
                aria-hidden="true"
                className="size-5 flex-none text-gray-400 dark:text-gray-500"
              />
            </PopoverButton>
            {/* Product 드롭다운 패널 */}
            <PopoverPanel
              transition
              className="absolute top-full -left-8 z-20 mt-3 w-screen max-w-md overflow-hidden rounded-3xl bg-white dark:bg-gray-800 shadow-lg ring-1 ring-gray-900/5 dark:ring-white/10 transition"
            >
              <div className="p-4">
                {products.map((item) => (
                  <div
                    key={item.name}
                    className="group relative flex items-center gap-x-6 rounded-lg p-4 text-xs/6 hover:bg-gray-50 dark:hover:bg-gray-700"
                  >
                    <div className="flex size-11 flex-none items-center justify-center rounded-lg bg-gray-50 dark:bg-gray-700 group-hover:bg-white dark:group-hover:bg-gray-600">
                      <item.icon
                        aria-hidden="true"
                        className="size-6 text-gray-600 dark:text-gray-400 group-hover:text-indigo-600 dark:group-hover:text-indigo-400"
                      />
                    </div>
                    <div className="flex-auto">
                      <a
                        href={item.href}
                        className="block font-semibold text-gray-900 dark:text-gray-100"
                      >
                        {item.name}
                        <span className="absolute inset-0" />
                      </a>
                      <p className="mt-1 text-gray-600 dark:text-gray-400">
                        {item.description}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
              {/* 하단 액션 버튼 */}
              <div className="grid grid-cols-2 divide-x divide-gray-900/5 dark:divide-white/10 bg-gray-50 dark:bg-gray-700/50">
                {callsToAction.map((item) => (
                  <a
                    key={item.name}
                    href={item.href}
                    className="flex items-center justify-center gap-x-2.5 p-3 text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-600"
                  >
                    <item.icon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500"
                    />
                    {item.name}
                  </a>
                ))}
              </div>
            </PopoverPanel>
          </Popover>
          {/* 타임라인 페이지로 이동하는 메뉴 */}
          <Link
            to="/timeline"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Timeline
          </Link>
          <Link
            to="/apps"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Apps
          </Link>
          <a
            href="#"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Company
          </a>
        </PopoverGroup>
        {/* 데스크탑: 다크모드 토글 + 로그인 */}
        <div className="hidden lg:flex lg:flex-1 lg:items-center lg:justify-end lg:gap-x-6">
          <button
            onClick={toggleDarkMode}
            className="p-2 rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none"
            aria-label="Toggle dark mode"
          >
            {darkMode ? (
              <SunIcon className="size-5" />
            ) : (
              <MoonIcon className="size-5" />
            )}
          </button>
          <a
            href="#"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Log in <span aria-hidden="true">&rarr;</span>
          </a>
        </div>
      </nav>
      {/* 모바일 메뉴 다이얼로그: 작은 화면에서만 열림 */}
      <Dialog
        open={mobileMenuOpen}
        onClose={setMobileMenuOpen}
        className="lg:hidden"
      >
        <div className="fixed inset-0 z-20" />
        <DialogPanel className="fixed inset-y-0 right-0 z-30 w-full overflow-y-auto bg-white dark:bg-gray-800 px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10 dark:sm:ring-white/10">
          <div className="flex items-center justify-between">
            <Link
              to="/"
              className="-m-1.5 p-1.5"
              onClick={() => setMobileMenuOpen(false)}
            >
              <span className="sr-only">Your Company</span>
              <img
                alt="Company Logo"
                src="https://tailwindcss.com/img/logos/mark.svg?color=indigo&shade=600"
                className="h-8 w-auto"
              />
            </Link>
            <button
              type="button"
              onClick={() => setMobileMenuOpen(false)}
              className="-m-2.5 rounded-md p-2.5 text-gray-700 dark:text-gray-300"
            >
              <span className="sr-only">Close menu</span>
              <XMarkIcon aria-hidden="true" className="size-6" />
            </button>
          </div>
          <div className="mt-6 flow-root">
            <div className="-my-6 divide-y divide-gray-500/10 dark:divide-gray-700">
              <div className="space-y-2 py-6">
                {/* Product 드롭다운 (모바일) */}
                <Disclosure as="div" className="-mx-3">
                  <DisclosureButton className="group flex w-full items-center justify-between rounded-lg py-2 pr-3.5 pl-3 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700">
                    Product
                    <ChevronDownIcon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500 group-data-open:rotate-180"
                    />
                  </DisclosureButton>
                  <DisclosurePanel className="mt-2 space-y-2">
                    {[...products, ...callsToAction].map((item) => (
                      <DisclosureButton
                        key={item.name}
                        as="a"
                        href={item.href}
                        onClick={() => setMobileMenuOpen(false)}
                        className="block rounded-lg py-2 pr-3 pl-6 text-sm/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                      >
                        {item.name}
                      </DisclosureButton>
                    ))}
                  </DisclosurePanel>
                </Disclosure>
                {/* 주요 메뉴들 */}
                <Link
                  to="/timeline"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Timeline
                </Link>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Marketplace
                </a>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Company
                </a>
              </div>
              <div className="py-6">
                {/* 다크모드 토글 (모바일) */}
                <button
                  onClick={() => {
                    toggleDarkMode();
                    setMobileMenuOpen(false);
                  }}
                  className="-mx-3 flex items-center gap-x-2 w-full rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                  aria-label="Toggle dark mode"
                >
                  {darkMode ? (
                    <SunIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  ) : (
                    <MoonIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  )}
                  {darkMode ? "라이트 모드" : "다크 모드"}
                </button>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Log in
                </a>
              </div>
            </div>
          </div>
        </DialogPanel>
      </Dialog>
    </header>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\components\Drawer\index.jsx -----

import React from "react";
import { XMarkIcon } from "@heroicons/react/24/outline";

export default function Drawer({ isOpen, onClose, title, children }) {
  return (
    <>
      {/* 배경 오버레이 - 완전 투명 */}
      {isOpen && (
        <div className="fixed inset-0 bg-black/20 z-40" onClick={onClose} />
      )}

      {/* 드로어 패널 - navbar 아래부터 시작 */}
      <div
        className={`fixed right-0 top-[125px] h-[calc(100vh-150px)] w-80 bg-white dark:bg-slate-800 shadow-xl z-40 rounded-l-2xl transform transition-transform duration-300 ease-in-out ${
          isOpen ? "translate-x-0" : "translate-x-full"
        }`}
      >
        {/* 헤더 */}
        <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white">
            {title}
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-500 dark:hover:text-gray-300 focus:outline-none"
          >
            <XMarkIcon className="h-6 w-6" />
          </button>
        </div>

        {/* 컨텐츠 */}
        <div className="p-4 overflow-y-auto h-[calc(100%-4rem)]">
          {children}
        </div>
      </div>
    </>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\components\LoadingSpinner\index.jsx -----

export default function LoadingSpinner() {
  return (
    <div className="flex justify-center items-center" role="status">
      <div className="animate-spin rounded-full h-5 w-5 border-4 border-blue-500 border-t-transparent" />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\components\index.js -----

export { default as LoadingSpinner } from './LoadingSpinner';
export { default as Drawer } from './Drawer';


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\services\api\client.js -----

const DEFAULT_TIMEOUT = 10000; // 10초
const MAX_RETRIES = 3;

/**
 * 개선된 API 클라이언트
 * @param {string} url - API 엔드포인트
 * @param {Object} options - 요청 옵션
 * @param {number} options.timeout - 타임아웃 (ms)
 * @param {number} options.retries - 재시도 횟수
 * @param {Object} options.params - 쿼리 파라미터
 */
export const apiClient = async (
  url,
  { params, timeout = DEFAULT_TIMEOUT, retries = MAX_RETRIES, ...opts } = {}
) => {
  // 기본 URL 유효성 검사
  const baseUrl = import.meta.env.VITE_API_BASE_URL;
  if (!baseUrl) {
    throw new Error(
      "API_BASE_URL이 설정되지 않았습니다. 환경변수를 확인해주세요."
    );
  }

  // 쿼리스트링 생성
  const qs = params ? "?" + new URLSearchParams(params) : "";
  const fullUrl = baseUrl + url + qs;

  // AbortController로 타임아웃 처리
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  const executeRequest = async (attempt = 1) => {
    try {
      const response = await fetch(fullUrl, {
        headers: {
          "Content-Type": "application/json",
          ...opts.headers,
        },
        signal: controller.signal,
        ...opts,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text();
        let errorMessage;

        // HTTP 상태 코드별 메시지
        switch (response.status) {
          case 400:
            errorMessage = "잘못된 요청입니다.";
            break;
          case 401:
            errorMessage = "인증이 필요합니다.";
            break;
          case 403:
            errorMessage = "접근 권한이 없습니다.";
            break;
          case 404:
            errorMessage = "요청한 데이터를 찾을 수 없습니다.";
            break;
          case 500:
            errorMessage = "서버 오류가 발생했습니다.";
            break;
          case 503:
            errorMessage = "서비스를 일시적으로 사용할 수 없습니다.";
            break;
          default:
            errorMessage = errorText || `HTTP ${response.status} 오류`;
        }

        const error = new Error(errorMessage);
        error.status = response.status;
        error.url = fullUrl;
        throw error;
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);

      // 타임아웃 에러 처리
      if (error.name === "AbortError") {
        throw new Error(`요청 시간이 초과되었습니다. (${timeout}ms)`);
      }

      // 네트워크 에러이고 재시도 가능한 경우
      if (attempt < retries && isRetryableError(error)) {
        console.warn(
          `API 요청 실패 (${attempt}/${retries}): ${error.message}. 재시도 중...`
        );
        await delay(Math.pow(2, attempt) * 1000); // 지수 백오프
        return executeRequest(attempt + 1);
      }

      // 마지막 에러는 그대로 throw
      throw error;
    }
  };

  return executeRequest();
};

/**
 * 재시도 가능한 에러인지 확인
 */
function isRetryableError(error) {
  // 네트워크 에러나 5xx 서버 에러는 재시도 가능
  return (
    !error.status || // 네트워크 에러
    error.status >= 500 || // 서버 에러
    error.status === 408 || // Request Timeout
    error.status === 429 // Too Many Requests
  );
}

/**
 * 지연 함수
 */
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\store\index.js -----

export { useSelectionStore } from "./selectionStore";


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\store\selectionStore.js -----

import { create } from "zustand";

export const useSelectionStore = create((set) => ({
  /* —— A. 테이블·타임라인 동기 선택 —— */
  selectedRow: null,
  source: null,
  setSelectedRow: (row, src) => set({ selectedRow: row, source: src }),

  /* —— B. 드릴다운 상태 —— */
  lineId: "",
  sdwtId: "",
  prcGroup: "", // PRC Group 추가
  eqpId: "",
  setLine: (id) => set({ lineId: id, sdwtId: "", prcGroup: "", eqpId: "" }),
  setSdwt: (id) => set({ sdwtId: id, prcGroup: "", eqpId: "" }),
  setPrcGroup: (id) => set({ prcGroup: id, eqpId: "" }), // PRC Group setter 추가
  setEqp: (id) => set({ eqpId: id }),

  /* —— C. vis-timeline 인스턴스 풀 —— */
  pool: [],
  register: (tl) => set((s) => ({ pool: [...s.pool, tl] })),
  unregister: (tl) => set((s) => ({ pool: s.pool.filter((t) => t !== tl) })),

  syncRange: (self, start, end) =>
    set((state) => {
      state.pool.forEach((tl) => {
        if (tl !== self) tl.setWindow(start, end, { animation: false });
      });
      return state;
    }),
}));


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\src\shared\styles\index.css -----

/* src/shared/styles/index.css */
@import "tailwindcss";

/* 다크모드 설정 */
@custom-variant dark (&:where(.dark, .dark *));



----- C:\Users\pjw75\Desktop\Code\eqp-timeline\eslint.config.js -----

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\index.html -----

<!doctype html>
<html lang="en" class="bg-slate-50 dark:bg-slate-900">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EQP Timeline Viewer</title>
    <script>
      // 다크모드 초기화
      if (
        localStorage.theme === 'dark' ||
        (!localStorage.getItem('theme') &&
          window.matchMedia('(prefers-color-scheme: dark)').matches)
      ) {
        document.documentElement.classList.add('dark');
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/app/main.jsx"></script>

  </body>
</html>


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\tailwind.config.js -----

/** @type {import('tailwindcss').Config} */
import forms from "@tailwindcss/forms";

export default {
  darkMode: "class", // 버튼으로 다크모드 토글
  content: [
    "./index.html",
    "./src/**/*.{js,jsx}", // 템플릿 경로 (필수)
  ],
  theme: { extend: {} },
  plugins: [forms],

  keyframes: {
    fadeIn: {
      "0%": { opacity: "0", transform: "translateY(10px)" },
      "100%": { opacity: "1", transform: "translateY(0)" },
    },
  },
  animation: {
    "fade-in": "fadeIn 0.3s ease-out",
  },
};


----- C:\Users\pjw75\Desktop\Code\eqp-timeline\vite.config.js -----

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  plugins: [react(), tailwindcss()],

  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"),
      "@features": path.resolve(__dirname, "src/features"),
      "@shared": path.resolve(__dirname, "src/shared"),
      "@layouts": path.resolve(__dirname, "src/layouts"),
      "@app": path.resolve(__dirname, "src/app"),
    },
  },

  server: {
    host: "0.0.0.0", // LAN 공유 필요 없으면 지워도 무방
    port: 5173, // 기본값 5173, 충돌 시 변경
  },

  // 선택) 환경변수 프리픽스 늘리기
  envPrefix: ["VITE_", "PUBLIC_"],

  // 선택) 빌드 출력 경로·크기 경고
  build: {
    outDir: "dist",
    chunkSizeWarningLimit: 800,
  },
});

