
----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\hooks\useLineQueries.js -----

import { useQuery } from "@tanstack/react-query";
import { timelineApi } from "@/features/timeline/api/timelineApi";

// ① 라인 목록 (언제나 요청)
export const useLines = () =>
  useQuery({
    queryKey: ["lines"],
    queryFn: timelineApi.fetchLines,
    staleTime: 1000 * 60 * 30,
  });

// ② SDWT 목록 (lineId 가 있어야 동작)
export const useSDWT = (lineId) =>
  useQuery({
    queryKey: ["sdwts", lineId],
    queryFn: () => timelineApi.fetchSDWT(lineId),
    enabled: !!lineId,
    staleTime: 1000 * 60 * 30,
  });

// ③ PRC Group 목록 (lineId와 sdwtId가 있어야 동작)
export const usePrcGroups = (lineId, sdwtId) =>
  useQuery({
    queryKey: ["prcGroups", lineId, sdwtId],
    queryFn: () => timelineApi.fetchPrcGroups(lineId, sdwtId),
    enabled: !!lineId && !!sdwtId,
    staleTime: 1000 * 60 * 30,
  });

// ④ EQP 목록 (line + sdwt + prcGroup 모두 골랐을 때만)
export const useEquipments = (lineId, sdwtId, prcGroup) =>
  useQuery({
    queryKey: ["equipments", lineId, sdwtId, prcGroup],
    queryFn: () => timelineApi.fetchEquipments(lineId, sdwtId, prcGroup),
    enabled: !!lineId && !!sdwtId && !!prcGroup,
    staleTime: 1000 * 60 * 30,
  });


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\EqpSelector.jsx -----

// src/features/drilldown/EqpSelector.jsx
import React from "react";
import { useEquipments } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * EQP 드롭다운
 */
export default function EqpSelector({
  lineId,
  sdwtId,
  prcGroup,
  eqpId,
  setEqpId,
}) {
  // 데이터·상태 가져오기 - prcGroup 추가
  const { data: eqps = [], isLoading } = useEquipments(
    lineId,
    sdwtId,
    prcGroup
  );

  // Line, SDWT, PRC Group 모두 선택해야 활성화
  if (!lineId || !sdwtId || !prcGroup)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 h-8"
      >
        <option>EQP 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={eqpId}
      onChange={(e) => setEqpId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
      disabled={eqps.length === 0}
    >
      <option value="">EQP 선택…</option>
      {eqps.map((e) => (
        <option key={e.id} value={e.id}>
          {e.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\index.js -----

// src/features/drilldown/index.js
export { default as LineSelector } from "./LineSelector";
export { default as SDWTSelector } from "./SDWTSelector";
export { default as PrcGroupSelector } from "./PrcGroupSelector";
export { default as EqpSelector } from "./EqpSelector";


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\LineSelector.jsx -----

import React from "react";
import { useLines } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * 라인 목록 드롭다운
 */
export default function LineSelector({ lineId, setLineId }) {
  const { data: lines = [], isLoading } = useLines();

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={lineId}
      onChange={(e) => setLineId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
    >
      <option value="">라인 선택…</option>
      {lines.map((l) => (
        <option key={l.id} value={l.id}>
          {l.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\PrcGroupSelector.jsx -----

// src/features/drilldown/PrcGroupSelector.jsx
import React from "react";
import { usePrcGroups } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * PRC Group 드롭다운
 */
export default function PrcGroupSelector({
  lineId,
  sdwtId,
  prcGroup,
  setPrcGroup,
}) {
  const { data: prcGroups = [], isLoading } = usePrcGroups(lineId, sdwtId);

  if (!lineId || !sdwtId)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 h-8"
      >
        <option>PRC Group 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={prcGroup}
      onChange={(e) => setPrcGroup(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
      disabled={prcGroups.length === 0}
    >
      <option value="">PRC Group 선택…</option>
      {prcGroups.map((p) => (
        <option key={p.id} value={p.id}>
          {p.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\drilldown\SDWTSelector.jsx -----

import React from "react";
import { useSDWT } from "./hooks/useLineQueries";
import LoadingSpinner from "@/shared/LoadingSpinner";

/**
 * SDWT 드롭다운
 */
export default function SDWTSelector({ lineId, sdwtId, setSdwtId }) {
  const { data: sdwts = [], isLoading } = useSDWT(lineId);

  if (!lineId)
    return (
      <select
        disabled
        className="w-full px-3 py-1.5 border rounded-lg bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 h-8"
      >
        <option>SDWT 선택…</option>
      </select>
    );

  if (isLoading) return <LoadingSpinner />;

  return (
    <select
      value={sdwtId}
      onChange={(e) => setSdwtId(e.target.value)}
      className="w-full px-3 py-1.5 border border-slate-300 dark:border-slate-600 rounded-lg bg-white dark:bg-slate-700 text-xs dark:text-slate-100 focus:ring-2 focus:ring-indigo-500 h-8"
    >
      <option value="">SDWT 선택…</option>
      {sdwts.map((s) => (
        <option key={s.id} value={s.id}>
          {s.name}
        </option>
      ))}
    </select>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\table\LogDetailSection.jsx -----

import React, { useState, useEffect } from "react";

// 스트리밍 텍스트 컴포넌트
function StreamingText({ text, speed = 30 }) {
  const [displayedText, setDisplayedText] = useState("");
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    // 텍스트가 변경되면 초기화
    setDisplayedText("");
    setCurrentIndex(0);
  }, [text]);

  useEffect(() => {
    if (currentIndex < text.length) {
      const timer = setTimeout(() => {
        setDisplayedText((prev) => prev + text[currentIndex]);
        setCurrentIndex((prev) => prev + 1);
      }, speed);

      return () => clearTimeout(timer);
    }
  }, [currentIndex, text, speed]);

  return (
    <span className="inline-block">
      {displayedText}
      {currentIndex < text.length && (
        <span className="inline-block w-2 h-4 bg-slate-600 dark:bg-slate-400 animate-pulse ml-0.5" />
      )}
    </span>
  );
}

// 필드 공통 출력용
function Field({ label, value, className, streaming = false }) {
  return (
    <>
      <div
        className={
          "font-semibold text-slate-700 dark:text-slate-200 " +
          (className || "")
        }
      >
        {label}
      </div>
      <div>{streaming ? <StreamingText text={value || "-"} /> : value}</div>
    </>
  );
}

function UrlField({ url }) {
  return (
    <>
      <div className="font-semibold text-slate-700 dark:text-slate-200">
        URL
      </div>
      <div>
        <a
          href={url}
          className="text-blue-600 dark:text-blue-400 underline break-all"
          target="_blank"
          rel="noopener noreferrer"
        >
          {url}
        </a>
      </div>
    </>
  );
}

// 로그 타입별 렌더러
function renderDetailByType(log) {
  switch (log.logType) {
    case "EQP":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="EQP State" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="End Time" value={log.endTime ?? "-"} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field label="Duration" value={log.duration?.toFixed(1) ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
          />
        </>
      );
    case "TIP":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="TIP Event" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field label="Level" value={log.level ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
          />
          {log.url && <UrlField url={log.url} />}
        </>
      );
    case "RACB":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="RACB Alarm" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
          />
          {log.url && <UrlField url={log.url} />}
        </>
      );
    case "CTTTM":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="CTTTM" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Recipe" value={log.recipe ?? "-"} />
          <Field label="Operator" value={log.operator ?? "-"} />
          <Field label="Duration" value={log.duration?.toFixed(1) ?? "-"} />
          <Field
            label="Comment"
            value={log.comment ?? "-"}
            className="col-span-2"
            streaming={true} // CTTTM의 Comment만 스트리밍 효과 적용
          />
        </>
      );
    case "JIRA":
      return (
        <>
          <Field label="ID" value={log.id} />
          <Field label="Log Type" value={log.logType} />
          <Field label="Issue Status" value={log.eventType} />
          <Field label="Time" value={log.eventTime} />
          <Field label="Issue Key" value={log.issueKey ?? "-"} />
          <Field label="Assignee" value={log.assignee ?? "-"} />
          <Field label="Priority" value={log.priority ?? "-"} />
          <Field label="Reporter" value={log.reporter ?? "-"} />
          <Field
            label="Summary"
            value={log.summary ?? "-"}
            className="col-span-2"
          />
          <Field
            label="Description"
            value={log.description ?? "-"}
            className="col-span-2"
          />
          {log.url && <UrlField url={log.url} />}
        </>
      );
    default:
      return (
        <div className="col-span-2 text-slate-500 dark:text-slate-400 py-2">
          알 수 없는 로그 타입입니다.
        </div>
      );
  }
}

/**
 * 선택된 로그 상세정보를 보여주는 컴포넌트
 * @param {Object} log - 상세를 보여줄 로그 객체
 */
export default function LogDetailSection({ log }) {
  if (!log) {
    return (
      <div className="text-sm text-slate-500 dark:text-slate-400 text-center py-17">
        테이블이나 타임라인에서 로그를 선택하면 상세정보가 표시됩니다.
      </div>
    );
  }

  return (
    <div
      className="grid grid-cols-2 gap-x-4 gap-y-2 text-xs
      bg-white dark:bg-slate-800 rounded-lg p-2
      text-slate-800 dark:text-slate-100 overflow-auto table-scroll"
    >
      {renderDetailByType(log)}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\table\VirtualizedDataTable.jsx -----

// src/features/table/VirtualizedDataTable.jsx
import React, { useEffect, useRef, useCallback, useMemo } from "react";
import { FixedSizeList as List } from "react-window";
import { useSelectionStore } from "@/shared/store";

/**
 * 가상화된 데이터 테이블 컴포넌트
 * react-window를 사용하여 대량의 데이터도 부드럽게 렌더링
 */
export default function VirtualizedDataTable({
  data,
  typeFilters,
  handleFilter,
}) {
  const { selectedRow, source, setSelectedRow } = useSelectionStore();
  const listRef = useRef(null);
  const scrollAnimationRef = useRef(null);

  // 오버스캔 카운트 증가로 더 많은 행을 미리 렌더링
  const OVERSCAN_COUNT = 10;
  const ITEM_HEIGHT = 36;

  // 부드러운 스크롤 함수
  const smoothScrollTo = useCallback((targetOffset, duration = 200) => {
    if (!listRef.current) return;

    const startOffset = listRef.current.state.scrollOffset;
    const distance = targetOffset - startOffset;
    const startTime = performance.now();

    const animateScroll = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      // easeInOutQuad 이징 함수
      const easeProgress =
        progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

      const currentOffset = startOffset + distance * easeProgress;

      // react-window의 scrollTo 메서드 사용
      listRef.current.scrollTo(currentOffset);

      if (progress < 1) {
        scrollAnimationRef.current = requestAnimationFrame(animateScroll);
      }
    };

    // 이전 애니메이션 취소
    if (scrollAnimationRef.current) {
      cancelAnimationFrame(scrollAnimationRef.current);
    }

    requestAnimationFrame(animateScroll);
  }, []);

  // 타임라인에서 선택된 항목이 있을 때 해당 행으로 스크롤
  useEffect(() => {
    if (
      source === "timeline" &&
      selectedRow &&
      listRef.current &&
      data.length > 0
    ) {
      const index = data.findIndex(
        (row) => String(row.id) === String(selectedRow)
      );

      if (index >= 0) {
        // 목표 위치 계산 (화면 중앙에 오도록)
        const listHeight = containerHeight;
        const targetOffset =
          index * ITEM_HEIGHT - listHeight / 2 + ITEM_HEIGHT / 2;
        const maxOffset = data.length * ITEM_HEIGHT - listHeight;
        const finalOffset = Math.max(0, Math.min(targetOffset, maxOffset));

        // 부드러운 스크롤 실행
        smoothScrollTo(finalOffset);
      }
    }
  }, [selectedRow, source, data, smoothScrollTo]);

  // 컴포넌트 언마운트 시 애니메이션 정리
  useEffect(() => {
    return () => {
      if (scrollAnimationRef.current) {
        cancelAnimationFrame(scrollAnimationRef.current);
      }
    };
  }, []);

  // 컬럼 너비 정의 (px 단위로 통일)
  const columnWidths = {
    time: 112,
    logType: 80,
    changeType: 160,
    operator: 70,
    duration: 70,
    url: 70,
  };

  // 헤더 컴포넌트
  const TableHeader = useMemo(
    () => (
      <div className="sticky top-0 z-10 bg-gray-200 text-gray-900 dark:bg-gray-600 dark:text-gray-100">
        <div className="flex text-xs font-semibold">
          <div
            style={{ width: `${columnWidths.time}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            Time
          </div>
          <div
            style={{ width: `${columnWidths.logType}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            LogType
          </div>
          <div
            style={{ width: `${columnWidths.changeType}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            ChangeType
          </div>
          <div
            style={{ width: `${columnWidths.operator}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            Operator
          </div>
          <div
            style={{ width: `${columnWidths.duration}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            Duration
          </div>
          <div
            style={{ width: `${columnWidths.url}px` }}
            className="px-2 py-2 text-center flex-shrink-0"
          >
            URL
          </div>
        </div>
      </div>
    ),
    [columnWidths]
  );

  // 필터 체크박스 컴포넌트
  const FilterCheckboxes = useMemo(
    () => (
      <div className="flex gap-3 flex-wrap mr-3">
        {Object.entries(typeFilters).map(([type, checked]) => (
          <label
            key={type}
            className="flex items-center gap-1 text-xs font-bold"
          >
            <input
              type="checkbox"
              name={type}
              checked={checked}
              onChange={handleFilter}
              className="rounded border-gray-300 dark:border-slate-600"
            />
            {type.replace("_LOG", "")}
          </label>
        ))}
      </div>
    ),
    [typeFilters, handleFilter]
  );

  // 행 렌더링 함수 - React.memo로 최적화
  const Row = React.memo(({ index, style }) => {
    const row = data[index];
    const isSel = String(row.id) === String(selectedRow);

    const handleClick = () => {
      setSelectedRow(isSel ? null : row.id, "table");
    };

    const handleUrlClick = (e) => {
      e.stopPropagation();
      if (row.url) {
        window.open(row.url, "_blank", "noopener,noreferrer");
      }
    };

    return (
      <div
        style={{
          ...style,
          // will-change로 브라우저에 최적화 힌트 제공
          willChange: "transform",
        }}
        onClick={handleClick}
        className={`flex items-center cursor-pointer border-b border-gray-100 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700 ${
          isSel
            ? "bg-yellow-200 dark:bg-yellow-800 dark:ring-yellow-700 transition-all duration-200"
            : "bg-white dark:bg-gray-800 transition-colors duration-150"
        }`}
      >
        <div
          style={{ width: `${columnWidths.time}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.displayTimestamp}
        </div>
        <div
          style={{ width: `${columnWidths.logType}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          <span
            className={`
            inline-block px-2 py-1 text-xs font-medium rounded
            ${
              row.logType === "EQP"
                ? "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
                : ""
            }
            ${
              row.logType === "TIP"
                ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
                : ""
            }
            ${
              row.logType === "RACB"
                ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200"
                : ""
            }
            ${
              row.logType === "CTTTM"
                ? "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200"
                : ""
            }
            ${
              row.logType === "JIRA"
                ? "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200"
                : ""
            }
          `}
          >
            {row.logType}
          </span>
        </div>
        <div
          style={{ width: `${columnWidths.changeType}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.info1}
        </div>
        <div
          style={{ width: `${columnWidths.operator}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.info2}
        </div>
        <div
          style={{ width: `${columnWidths.duration}px` }}
          className="px-2 py-2 text-xs text-center text-gray-800 dark:text-gray-200 flex-shrink-0"
        >
          {row.duration}
        </div>
        <div
          style={{ width: `${columnWidths.url}px` }}
          className="px-2 py-2 text-xs text-center flex-shrink-0"
        >
          {row.url ? (
            <button
              onClick={handleUrlClick}
              className="inline-flex items-center justify-center w-8 h-8 rounded hover:bg-blue-100 dark:hover:bg-blue-900 transition-colors"
              title="Open URL"
            >
              <svg
                className="w-4 h-4 text-blue-600 dark:text-blue-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
                />
              </svg>
            </button>
          ) : (
            <span className="text-gray-400 dark:text-gray-600">-</span>
          )}
        </div>
      </div>
    );
  });

  Row.displayName = "Row";

  // 리스트 컨테이너의 높이 계산
  const [containerHeight, setContainerHeight] = React.useState(400);
  const containerRef = useRef(null);

  useEffect(() => {
    const updateHeight = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const availableHeight = rect.height - 120;
        setContainerHeight(Math.max(200, availableHeight));
      }
    };

    updateHeight();
    window.addEventListener("resize", updateHeight);
    return () => window.removeEventListener("resize", updateHeight);
  }, []);

  return (
    <div className="h-full flex flex-col overflow-hidden" ref={containerRef}>
      {/* 상단 필터 영역 */}
      <div className="flex justify-between items-center pt-1 bg-white dark:bg-slate-800 text-gray-900 dark:text-white rounded-t-lg">
        <h3 className="text-md font-semibold mb-5">📜 Data Log</h3>
        {FilterCheckboxes}
      </div>

      {/* 테이블 영역 */}
      <div className="flex-1 overflow-hidden">
        {data.length === 0 ? (
          <div className="text-center text-sm text-gray-500 dark:text-gray-400 p-4">
            표시할 데이터가 없습니다.
          </div>
        ) : (
          <div className="h-full bg-white dark:bg-gray-800 rounded-b-lg overflow-hidden">
            {TableHeader}
            <List
              ref={listRef}
              height={containerHeight}
              itemCount={data.length}
              itemSize={ITEM_HEIGHT}
              width="100%"
              overscanCount={OVERSCAN_COUNT}
              className="scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-100 dark:scrollbar-thumb-gray-600 dark:scrollbar-track-gray-800"
              style={{
                // 스크롤 성능 최적화
                contain: "strict",
                overflowAnchor: "none",
              }}
            >
              {Row}
            </List>
          </div>
        )}
      </div>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\api\timelineApi.js -----

import { apiClient } from "@/shared/apiClient";

export const timelineApi = {
  // "라인 목록" 엔드포인트
  fetchLines: () => apiClient("/lines"),

  // SDWT 목록
  fetchSDWT: (lineId) => apiClient("/sdwts", { params: { lineId } }),

  // PRC Group 목록
  fetchPrcGroups: (lineId, sdwtId) =>
    apiClient("/prc-groups", { params: { lineId, sdwtId } }),

  // Equipment 목록
  fetchEquipments: (lineId, sdwtId, prcGroup) => {
    const params = { lineId };
    if (sdwtId) params.sdwtId = sdwtId;
    if (prcGroup) params.prcGroup = prcGroup;
    return apiClient("/equipments", { params });
  },

  // 로그 가져오기 - sdwtId 제거
  fetchLogs: ({ lineId, eqpId }) =>
    apiClient("/logs", { params: { lineId, eqpId } }),

  // EQP 정보 조회
  fetchEquipmentInfo: (lineId, eqpId) =>
    apiClient(`/equipment-info/${lineId}/${eqpId}`),
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\DataLogSection.jsx -----

// src/features/timeline/components/DataLogSection.jsx
import React from "react";
import VirtualizedDataTable from "@/features/table/VirtualizedDataTable";
import LoadingSpinner from "@/shared/LoadingSpinner";

export default function DataLogSection({
  eqpId,
  logsLoading,
  tableData,
  typeFilters,
  handleFilter,
}) {
  return (
    <section className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex-[2] min-h-0 flex flex-col overflow-hidden">
      {!eqpId && !logsLoading ? (
        <p className="text-center text-sm text-slate-600 dark:text-slate-400 py-45">
          EQP를 선택하세요.
        </p>
      ) : logsLoading ? (
        <div className="flex items-center justify-center h-full">
          <LoadingSpinner />
        </div>
      ) : (
        <VirtualizedDataTable
          data={tableData}
          typeFilters={typeFilters}
          handleFilter={handleFilter}
        />
      )}
    </section>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\LegendToggle.jsx -----

// src/features/timeline/components/LegendToggle.jsx
import React from "react";

export default function LegendToggle({ showLegend, onToggle }) {
  return (
    <label className="inline-flex items-center cursor-pointer">
      <span className="text-xs font-medium text-gray-900 dark:text-gray-300 mr-2 font-bold">
        Show Legend
      </span>
      <input
        type="checkbox"
        value=""
        className="sr-only peer"
        checked={showLegend}
        onChange={onToggle}
      />
      <div className="relative w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600 dark:peer-checked:bg-blue-600"></div>
    </label>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\LogViewerSection.jsx -----

// src/features/timeline/components/LogViewerSection.jsx
import React from "react";
import { LineSelector, SDWTSelector, EqpSelector } from "@/features/drilldown";
import PrcGroupSelector from "@/features/drilldown/PrcGroupSelector";

export default function LogViewerSection({
  lineId,
  sdwtId,
  prcGroup,
  eqpId,
  setLine,
  setSdwt,
  setPrcGroup,
  setEqp,
}) {
  return (
    <section className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex flex-col">
      <h2 className="text-md font-bold text-slate-900 dark:text-white border-slate-200 dark:border-slate-700">
        📊 Log Viewer
      </h2>
      <div className="grid grid-cols-4 gap-2 mt-2">
        <LineSelector lineId={lineId} setLineId={setLine} />
        <SDWTSelector lineId={lineId} sdwtId={sdwtId} setSdwtId={setSdwt} />
        <PrcGroupSelector
          lineId={lineId}
          sdwtId={sdwtId}
          prcGroup={prcGroup}
          setPrcGroup={setPrcGroup}
        />
        <EqpSelector
          lineId={lineId}
          sdwtId={sdwtId}
          prcGroup={prcGroup}
          eqpId={eqpId}
          setEqpId={setEqp}
        />
      </div>
    </section>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\NonStackedTimeline.jsx -----

// src/features/timeline/components/NonStackedTimeline.jsx
import React, { useMemo, useRef } from "react";
import { processData } from "@/features/timeline/utils/timelineUtils";
import {
  makeGroupLabel,
  makeTipGroupLabel,
} from "@/features/timeline/utils/groupLabel";
import { useVisTimeline } from "../hooks/useVisTimeline";

export default function NonStackedTimeline({
  dataMap,
  range,
  showLegend,
  selectedTipGroups,
}) {
  const containerRef = useRef(null);

  // 필터링된 TIP 로그
  const filteredTipLogs = useMemo(() => {
    if (!dataMap.TIP) return [];

    // 선택된 그룹이 없으면 빈 배열 반환 (TIP 로그 숨김)
    if (!selectedTipGroups || selectedTipGroups.length === 0) return [];

    // 특별한 값 "__ALL__"이 포함되어 있으면 전체 표시
    if (selectedTipGroups.includes("__ALL__")) return dataMap.TIP;

    return dataMap.TIP.filter((log) => {
      const groupKey = `${log.process || "unknown"}_${log.step || "unknown"}_${
        log.ppid || "unknown"
      }`;
      return selectedTipGroups.includes(groupKey);
    });
  }, [dataMap.TIP, selectedTipGroups]);

  // TIP 그룹 동적 생성 (필터링된 로그 기반)
  const tipGroups = useMemo(() => {
    const groupMap = new Map();

    filteredTipLogs.forEach((log) => {
      const groupKey = `TIP_${log.process || "unknown"}_${
        log.step || "unknown"
      }_${log.ppid || "unknown"}`;
      if (!groupMap.has(groupKey)) {
        groupMap.set(groupKey, {
          id: groupKey,
          content: makeTipGroupLabel(
            log.process,
            log.step,
            log.ppid,
            showLegend
          ),
          className: showLegend
            ? "custom-group-label tip-group legend-mode"
            : "custom-group-label tip-group",
          order: 100 + groupMap.size,
          title: `Process: ${log.process || "N/A"} | Step: ${
            log.step || "N/A"
          } | PPID: ${log.ppid || "N/A"}`,
        });
      }
    });

    return Array.from(groupMap.values()).sort((a, b) => a.order - b.order);
  }, [filteredTipLogs, showLegend]);

  // 전체 그룹 정의
  const groups = useMemo(() => {
    const baseGroups = [
      {
        id: "EQP",
        content: makeGroupLabel("EQP", "EQP 로그", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
        order: 1,
      },
    ];

    return [...baseGroups, ...tipGroups];
  }, [showLegend, tipGroups]);

  // 아이템 목록 생성 (연속성 보장)
  const items = useMemo(() => {
    // EQP 아이템은 연속성 보장 (makeRangeContinuous = true)
    const eqpItems = processData("EQP", dataMap.EQP || [], true);

    // 필터링된 TIP 아이템을 각 그룹에 할당 (TIP도 range로 변경)
    const tipItems = [];

    // TIP 로그를 그룹별로 분류
    const tipGroupMap = new Map();
    filteredTipLogs.forEach((log) => {
      const groupKey = `TIP_${log.process || "unknown"}_${
        log.step || "unknown"
      }_${log.ppid || "unknown"}`;

      if (!tipGroupMap.has(groupKey)) {
        tipGroupMap.set(groupKey, []);
      }
      tipGroupMap.get(groupKey).push(log);
    });

    // 각 TIP 그룹별로 연속성 보장하여 아이템 생성
    tipGroupMap.forEach((logs, groupKey) => {
      const groupItems = processData("TIP", logs, true); // TIP도 range로 변경
      groupItems.forEach((item) => {
        tipItems.push({
          ...item,
          group: groupKey,
        });
      });
    });

    return [...eqpItems, ...tipItems];
  }, [dataMap.EQP, filteredTipLogs]);

  // vis-timeline 옵션 설정
  const options = useMemo(
    () => ({
      stack: false,
      min: range.min,
      max: range.max,
      zoomMin: 60 * 60 * 1000, // 10분으로 최소 줌 레벨 증가 (더 줌 아웃 가능)
      margin: { item: 0, axis: 0 },
      groupOrder: "order",
      selectable: true,
      verticalScroll: true,
      maxHeight: 400,
      tooltip: {
        followMouse: true,
        overflowMethod: "cap",
      },
    }),
    [range]
  );

  useVisTimeline({ containerRef, groups, items, options });

  return (
    <div className="timeline-container relative">
      {/* 타임라인 헤더 */}
      <div className="flex items-center justify-between mb-1">
        <h3 className="text-sm font-semibold text-slate-600 dark:text-slate-300">
          ⛓ EQP + TIP 로그
        </h3>
        {selectedTipGroups &&
          selectedTipGroups.length > 0 &&
          selectedTipGroups[0] !== "__ALL__" && (
            <span className="text-xs text-slate-500 dark:text-slate-400">
              {tipGroups.length}개의 TIP 그룹 표시 중
            </span>
          )}
      </div>

      {/* 타임라인 */}
      <div
        ref={containerRef}
        className="timeline"
        style={{ minHeight: "200px" }}
      />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\ShareButton.jsx -----

// src/features/timeline/components/ShareButton.jsx
import React, { useState } from "react";

export default function ShareButton() {
  const [showToast, setShowToast] = useState(false);
  const [showTooltip, setShowTooltip] = useState(false);

  const handleShare = async () => {
    const url = window.location.href;

    try {
      if (navigator.share) {
        await navigator.share({
          title: "EQP Timeline",
          text: "타임라인 링크를 공유합니다",
          url: url,
        });
      } else {
        await navigator.clipboard.writeText(url);
        setShowToast(true);
        setTimeout(() => setShowToast(false), 3000);
      }
    } catch (err) {
      console.error("URL 공유 실패:", err);
      const textArea = document.createElement("textarea");
      textArea.value = url;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
      setShowToast(true);
      setTimeout(() => setShowToast(false), 3000);
    }
  };

  return (
    <>
      {/* 부모 div에 relative position 추가 */}
      <div className="relative inline-block">
        <svg
          onClick={handleShare}
          className="w-5 h-5 text-blue-600 hover:text-blue-700 transition-colors cursor-pointer"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          onMouseEnter={() => setShowTooltip(true)}
          onMouseLeave={() => setShowTooltip(false)}
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
          />
        </svg>

        {/* 툴팁 */}
        {showTooltip && (
          <div className="absolute top-1/2 left-full transform -translate-y-1/2 ml-2 px-2 py-1 text-xs text-white bg-gray-800 rounded-md whitespace-nowrap pointer-events-none">
            URL 복사
            {/* 툴팁 화살표 추가 (선택사항) */}
            <div className="absolute top-1/2 right-full transform -translate-y-1/2 w-0 h-0 border-t-4 border-b-4 border-r-4 border-transparent border-r-gray-800"></div>
          </div>
        )}
      </div>

      {/* 토스트 메시지 */}
      {showToast && (
        <div className="fixed bottom-4 right-4 bg-green-600 text-white px-4 py-2 rounded-lg shadow-lg animate-fade-in z-50">
          URL이 클립보드에 복사되었습니다!
        </div>
      )}
    </>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\StackedTimeline.jsx -----

import React, { useMemo, useRef } from "react";
import { processData } from "@/features/timeline/utils/timelineUtils";
import { makeGroupLabel } from "@/features/timeline/utils/groupLabel";
import { useVisTimeline } from "../hooks/useVisTimeline";

/**
 * CTTTM_LOG + RACB_LOG + JIRA 를 stack=true 로 보여주는 타임라인
 */
export default function StackedTimeline({ dataMap, range, showLegend }) {
  // vis-timeline 이 그려질 DOM 요소 ref
  const containerRef = useRef(null);

  // 그룹(CTTTM, RACB, JIRA) 정의
  const groups = useMemo(
    () => [
      {
        id: "CTTTM",
        content: makeGroupLabel("CTTTM", "CTTTM 로그", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
      },
      {
        id: "RACB",
        content: makeGroupLabel("RACB", "RACB 로그", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
      },
      {
        id: "JIRA",
        content: makeGroupLabel("JIRA", "JIRA 로그", showLegend),
        className: showLegend
          ? "custom-group-label legend-mode"
          : "custom-group-label",
      },
    ],
    [showLegend]
  );

  // 타임라인에 표시할 아이템 배열
  const items = useMemo(
    () => groups.flatMap((g) => processData(g.id, dataMap[g.id] || [])),
    [dataMap, groups]
  );

  // vis-timeline 옵션 정의 - 외부에서 전달받은 range 사용
  const options = useMemo(
    () => ({
      stack: true,
      min: range.min,
      max: range.max,
      zoomMin: 60 * 60 * 1000, // 10분으로 최소 줌 레벨 증가 (더 줌 아웃 가능)
      verticalScroll: true,
      groupHeightMode: "fixed",
      groupOrder: (a, b) =>
        ["CTTTM", "RACB", "JIRA"].indexOf(a.id) -
        ["CTTTM", "RACB", "JIRA"].indexOf(b.id),
    }),
    [range]
  );

  // 커스텀 훅으로 vis-timeline 생성 및 업데이트 처리
  useVisTimeline({ containerRef, groups, items, options });

  return (
    <div className="timeline-container">
      <h3 className="text-sm font-semibold mb-1 text-slate-600 dark:text-slate-300">
        📍 변경점 로그
      </h3>
      {/* 실제 타임라인이 렌더링될 영역 */}
      <div
        ref={containerRef}
        className="timeline"
        style={{ height: "650px", overflow: "hidden" }}
      />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\TimelineBoard.jsx -----

// src/features/timeline/components/TimelineBoard.jsx
import React, { useMemo } from "react";
import NonStackedTimeline from "./NonStackedTimeline";
import StackedTimeline from "./StackedTimeline";
import { calcRange, addBuffer } from "@/features/timeline/utils/timelineUtils";

export default function TimelineBoard({
  dataMap,
  showLegend,
  selectedTipGroups,
}) {
  const eqpLogArr = dataMap.EQP || [];
  const tipLogArr = dataMap.TIP || [];
  const ctttmLogArr = dataMap.CTTTM || [];
  const racbLogArr = dataMap.RACB || [];
  const jiraLogArr = dataMap.JIRA || [];

  const allLogs = useMemo(
    () => [
      ...eqpLogArr,
      ...tipLogArr,
      ...ctttmLogArr,
      ...racbLogArr,
      ...jiraLogArr,
    ],
    [eqpLogArr, tipLogArr, ctttmLogArr, racbLogArr, jiraLogArr]
  );

  const fullRange = useMemo(() => {
    const r = calcRange(allLogs);
    return addBuffer(r.min.getTime(), r.max.getTime());
  }, [allLogs]);

  // 범위 디버깅 (선택사항)
  console.log("Timeline Range:", {
    min: fullRange.min.toISOString(),
    max: fullRange.max.toISOString(),
    logCount: allLogs.length,
    selectedTipGroups: selectedTipGroups, // 디버깅용
  });

  return (
    <div className="w-full space-y-4">
      <NonStackedTimeline
        dataMap={{ EQP: eqpLogArr, TIP: tipLogArr }}
        range={fullRange}
        showLegend={showLegend}
        selectedTipGroups={selectedTipGroups}
      />
      <StackedTimeline
        dataMap={{ CTTTM: ctttmLogArr, RACB: racbLogArr, JIRA: jiraLogArr }}
        range={fullRange}
        showLegend={showLegend}
      />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\TimelineSettings.jsx -----

import React from "react";
import LegendToggle from "./LegendToggle";
import TipFilterChips from "./TipFilterChips";

export default function TimelineSettings({
  showLegend,
  onLegendToggle,
  tipLogs,
  selectedTipGroups, // 추가
  onTipFilterChange,
}) {
  return (
    <div className="space-y-6">
      {/* Legend 설정 섹션 */}
      <div className="border-b border-gray-200 dark:border-gray-700 pb-6">
        <h3 className="text-sm font-semibold text-gray-900 dark:text-white mb-4">
          표시 설정
        </h3>
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <span className="text-xs text-gray-700 dark:text-gray-300">
              타임라인 범례 표시
            </span>
            <LegendToggle showLegend={showLegend} onToggle={onLegendToggle} />
          </div>
        </div>
      </div>

      {/* TIP 필터 섹션 */}
      {tipLogs && tipLogs.length > 0 && (
        <div>
          <h3 className="text-sm font-semibold text-gray-900 dark:text-white mb-4">
            TIP 그룹 필터
          </h3>
          <TipFilterChips
            tipLogs={tipLogs}
            selectedTipGroups={selectedTipGroups} // 추가
            onFilterChange={onTipFilterChange}
            inDrawer={true}
          />
        </div>
      )}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\components\TipFilterChips.jsx -----

import React, { useMemo, useState, useEffect } from "react";
import { XMarkIcon } from "@heroicons/react/20/solid";

export default function TipFilterChips({
  tipLogs,
  onFilterChange,
  inDrawer = false,
}) {
  const [selectedGroups, setSelectedGroups] = useState(new Set());
  const [showAll, setShowAll] = useState(false);
  const [isAllSelected, setIsAllSelected] = useState(true); // 초기값은 전체 선택

  // TIP 로그를 그룹별로 정리
  const tipGroups = useMemo(() => {
    const groupMap = new Map();

    tipLogs.forEach((log) => {
      const groupKey = `${log.process || "unknown"}_${log.step || "unknown"}_${
        log.ppid || "unknown"
      }`;
      if (!groupMap.has(groupKey)) {
        groupMap.set(groupKey, {
          key: groupKey,
          process: log.process || "unknown",
          step: log.step || "unknown",
          ppid: log.ppid || "unknown",
          count: 0,
        });
      }
      groupMap.get(groupKey).count++;
    });

    return Array.from(groupMap.values()).sort((a, b) => {
      if (a.process !== b.process) return a.process.localeCompare(b.process);
      if (a.step !== b.step) return a.step.localeCompare(b.step);
      return a.ppid.localeCompare(b.ppid);
    });
  }, [tipLogs]);

  // 표시할 그룹 (처음 5개 또는 전체)
  const displayGroups = showAll ? tipGroups : tipGroups.slice(0, 5);

  // 선택 상태가 변경될 때마다 부모 컴포넌트에 알림
  useEffect(() => {
    if (isAllSelected) {
      // 전체 선택 상태면 특별한 값 전달
      onFilterChange(["__ALL__"]);
    } else if (selectedGroups.size === 0) {
      // 아무것도 선택되지 않으면 빈 배열
      onFilterChange([]);
    } else {
      // 선택된 그룹들만 전달
      onFilterChange(Array.from(selectedGroups));
    }
  }, [selectedGroups, isAllSelected, onFilterChange]);

  // 그룹 선택/해제 핸들러
  const handleGroupToggle = (groupKey) => {
    if (isAllSelected) {
      // 전체 선택 상태에서 하나를 클릭하면, 나머지를 모두 선택하고 클릭한 것만 해제
      const newSelected = new Set(tipGroups.map((g) => g.key));
      newSelected.delete(groupKey);
      setSelectedGroups(newSelected);
      setIsAllSelected(false);
    } else {
      const newSelected = new Set(selectedGroups);
      if (newSelected.has(groupKey)) {
        newSelected.delete(groupKey);
      } else {
        newSelected.add(groupKey);
      }

      // 모든 그룹이 선택되면 전체 선택 상태로 변경
      if (newSelected.size === tipGroups.length) {
        setIsAllSelected(true);
        setSelectedGroups(new Set());
      } else {
        setSelectedGroups(newSelected);
      }
    }
  };

  // 전체 선택/해제
  const handleSelectAll = () => {
    if (isAllSelected || selectedGroups.size === tipGroups.length) {
      // 전체 해제
      setSelectedGroups(new Set());
      setIsAllSelected(false);
    } else {
      // 전체 선택
      setSelectedGroups(new Set());
      setIsAllSelected(true);
    }
  };

  // 그룹이 선택되었는지 확인
  const isGroupSelected = (groupKey) => {
    if (isAllSelected) return true;
    return selectedGroups.has(groupKey);
  };

  return (
    <div
      className={
        inDrawer ? "" : "bg-white dark:bg-slate-800 rounded-lg p-3 mb-2"
      }
    >
      <div className="flex items-center justify-between mb-2">
        {!inDrawer && (
          <h4 className="text-xs font-semibold text-slate-900 dark:text-white">
            TIP 그룹 필터
          </h4>
        )}
        <div
          className={`flex items-center gap-2 ${
            inDrawer ? "w-full justify-end" : ""
          }`}
        >
          <button
            onClick={handleSelectAll}
            className="text-xs text-blue-700 dark:text-blue-300 hover:underline dark:hover:text-blue-300"
          >
            {isAllSelected || selectedGroups.size === tipGroups.length
              ? "전체 해제"
              : "전체 선택"}
          </button>
        </div>
      </div>

      <div className="flex flex-wrap gap-1.5">
        {displayGroups.map((group) => {
          const isSelected = isGroupSelected(group.key);
          return (
            <button
              key={group.key}
              onClick={() => handleGroupToggle(group.key)}
              className={`
                inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium
                transition-all duration-200 border
                ${
                  isSelected
                    ? "bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 border-blue-300 dark:border-blue-700"
                    : "bg-gray-100 dark:bg-gray-700 text-gray-500 dark:text-gray-400 border-gray-300 dark:border-gray-600 opacity-60"
                }
                hover:opacity-100
              `}
              title={`Process: ${group.process} | Step: ${group.step} | PPID: ${group.ppid}`}
            >
              <span className="font-semibold">{group.ppid}</span>
              <span className="text-[10px] text-gray-600 dark:text-gray-400">
                ({group.count})
              </span>
              {isSelected && <XMarkIcon className="w-3 h-3 ml-0.5" />}
            </button>
          );
        })}

        {!showAll && tipGroups.length > 5 && (
          <button
            onClick={() => setShowAll(true)}
            className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium
              bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300
              hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
          >
            +{tipGroups.length - 5} 더보기
          </button>
        )}
      </div>

      {!isAllSelected && selectedGroups.size === 0 && (
        <div className="mt-2 text-xs text-slate-600 dark:text-slate-400">
          PPID 선택하세요
        </div>
      )}
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\constants\index.js -----

export const DATA_TYPES = {
  EQP: "EQP",
  TIP: "TIP",
  RACB: "RACB",
  CTTTM: "CTTTM",
  JIRA: "JIRA",
};

export const DEFAULT_TYPE_FILTERS = {
  [DATA_TYPES.EQP]: true,
  [DATA_TYPES.TIP]: true,
  [DATA_TYPES.RACB]: true,
  [DATA_TYPES.CTTTM]: true,
  [DATA_TYPES.JIRA]: true,
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useLogQueries.js -----

// src/features/timeline/hooks/useLogQueries.js
import { useQuery } from "@tanstack/react-query";
import { timelineApi } from "@/features/timeline/api/timelineApi";

export const useLogs = ({ lineId, eqpId }, enabled) =>
  useQuery({
    queryKey: ["logs", lineId, eqpId],
    queryFn: () => timelineApi.fetchLogs({ lineId, eqpId }),
    enabled,
    staleTime: 1000 * 60 * 5,
  });


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useUrlSync.js -----

// src/features/timeline/hooks/useUrlSync.js
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";

export function useUrlSync(lineId, eqpId, isValidating, isUrlInitialized) {
  const navigate = useNavigate();

  useEffect(() => {
    if (isValidating || !isUrlInitialized) return;

    const currentPath = window.location.pathname;
    const isParamRoute =
      currentPath.includes("/timeline/") && currentPath.split("/").length > 3;

    if (lineId && eqpId) {
      const newPath = `/timeline/${lineId}/${eqpId}`;
      if (currentPath !== newPath) {
        navigate(newPath, { replace: true });
      }
    } else {
      if (isParamRoute) {
        navigate("/timeline", { replace: true });
      }
    }
  }, [lineId, eqpId, navigate, isValidating, isUrlInitialized]);
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useUrlValidation.js -----

// src/features/timeline/hooks/useUrlValidation.js
import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
// import { useLines } from "@/features/drilldown/hooks/useLineQueries"; // 불필요한 의존성 제거
import { timelineApi } from "@/features/timeline/api/timelineApi";

export function useUrlValidation(
  params,
  lineId,
  eqpId,
  setLine,
  setSdwt,
  setPrcGroup,
  setEqp
) {
  const [isValidating, setIsValidating] = useState(false);
  const [validationError, setValidationError] = useState(null);
  const [isUrlInitialized, setIsUrlInitialized] = useState(false);

  const navigate = useNavigate();
  // const { data: lines = [] } = useLines(); // 불필요한 의존성 제거

  useEffect(() => {
    const validateAndSetParams = async () => {
      if (params.lineId && params.eqpId) {
        setIsValidating(true);
        setValidationError(null);
        setIsUrlInitialized(true);

        try {
          const eqpInfo = await timelineApi.fetchEquipmentInfo(
            params.lineId,
            params.eqpId
          );

          // 백엔드에서 이미 유효성 검증이 완료됨
          if (!eqpInfo) {
            setValidationError("유효하지 않은 Line ID 또는 EQP ID입니다.");
            setTimeout(() => navigate("/timeline"), 1500);
            return;
          }

          // 상태 업데이트
          setLine(params.lineId);
          setSdwt(eqpInfo.sdwtId);
          setPrcGroup(eqpInfo.prcGroup);
          setEqp(params.eqpId);
        } catch {
          setValidationError("데이터 검증 중 오류가 발생했습니다.");
          setTimeout(() => navigate("/timeline"), 1500);
        } finally {
          setIsValidating(false);
        }
      } else {
        setIsUrlInitialized(true);
      }
    };

    if (!isUrlInitialized) {
      validateAndSetParams();
    }
  }, [
    params.lineId,
    params.eqpId,
    isUrlInitialized,
    navigate,
    setLine,
    setSdwt,
    setPrcGroup,
    setEqp,
  ]);

  return { isValidating, validationError, isUrlInitialized };
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\hooks\useVisTimeline.js -----

import { useEffect, useRef } from "react";
import { DataSet } from "vis-data";
import { useSelectionStore } from "@/shared/store";

/**
 * vis-timeline 생성을 공통 처리하는 훅
 * @param {Object} params
 * @param {React.RefObject} params.containerRef - 타임라인 DOM을 가리키는 ref
 * @param {Array} params.groups - vis-timeline 그룹 배열
 * @param {Array} params.items - vis-timeline 아이템 배열
 * @param {Object} params.options - vis-timeline 옵션
 */
export function useVisTimeline({ containerRef, groups, items, options }) {
  // vis-timeline 인스턴스 보관용 ref
  const tlRef = useRef(null);
  // 전역 스토어에서 타임라인 풀 관리 및 선택 상태 제어 함수 사용
  const { register, unregister, syncRange, setSelectedRow, selectedRow } =
    useSelectionStore();

  // 1. 컴포넌트 마운트 시 한 번만 인스턴스 생성
  useEffect(() => {
    let mounted = true;
    (async () => {
      const { Timeline } = await import("vis-timeline/standalone");
      if (!mounted || !containerRef.current) return;

      // 초기 아이템/그룹으로 타임라인을 생성
      const dataset = new DataSet(items);
      tlRef.current = new Timeline(
        containerRef.current,
        dataset,
        groups,
        options
      );

      register(tlRef.current);

      // 다른 타임라인과 범위 동기화
      tlRef.current.on("rangechange", ({ start, end }) =>
        syncRange(tlRef.current, start, end)
      );

      // 아이템 선택 시 전역 상태에 반영
      tlRef.current.on("select", ({ items }) => {
        const currentSelected = useSelectionStore.getState().selectedRow;
        if (items && items.length > 0) {
          if (String(currentSelected) === String(items[0])) {
            setSelectedRow(null, "timeline");
            tlRef.current.setSelection([]);
          } else {
            setSelectedRow(items[0], "timeline");
          }
        } else {
          setSelectedRow(null, "timeline");
        }
      });
    })();

    return () => {
      mounted = false;
      if (tlRef.current) {
        // 스토어와 연결 해제 후 인스턴스 파괴
        unregister(tlRef.current);
        tlRef.current.destroy();
      }
    };
  }, []);

  // 2. 아이템 배열이 바뀌면 교체
  useEffect(() => {
    if (tlRef.current) {
      tlRef.current.setItems(new DataSet(items));
    }
  }, [items]);

  // 3. 그룹 정보 변경 시 갱신 (visibility 처리 포함)
  useEffect(() => {
    if (tlRef.current && groups) {
      // vis-timeline의 그룹 visibility 설정
      const updatedGroups = groups.map((g) => ({
        ...g,
        visible: g.visible !== false,
      }));
      tlRef.current.setGroups(updatedGroups);
    }
  }, [groups]);

  // 4. 옵션 변경 시 범위 업데이트 (동기화 개선)
  useEffect(() => {
    if (tlRef.current && options.min && options.max) {
      tlRef.current.setWindow(options.min, options.max, { animation: false });
    }
  }, [options.min, options.max]);

  // 5. 외부에서 선택된 행을 타임라인에 반영
  useEffect(() => {
    if (tlRef.current) {
      if (selectedRow && tlRef.current.itemsData.get(selectedRow)) {
        tlRef.current.setSelection([selectedRow]);
      } else {
        tlRef.current.setSelection([]);
      }
    }
  }, [selectedRow]);

  return tlRef;
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\utils\dataTransformers.js -----

// src/features/timeline/utils/dataTransformers.js
import { formatDateTime } from "@/shared/dateUtils";

export function groupLogsByType(logs) {
  const groups = { EQP: [], TIP: [], RACB: [], CTTTM: [], JIRA: [] };
  logs.forEach((log) => {
    if (groups[log.logType]) {
      groups[log.logType].push(log);
    }
  });
  return groups;
}

export function transformLogsToTableData(logs, typeFilters) {
  const transformed = logs
    .filter((log) => typeFilters[log.logType])
    .map((log) => {
      const row = {
        id: log.id,
        timestamp: new Date(log.eventTime).getTime(),
        displayTimestamp: formatDateTime(log.eventTime),
        logType: log.logType,
        info1: log.eventType,
        info2: log.operator || "-",
        duration: "-", // duration은 더 이상 계산하지 않음
        url: log.url || null,
      };

      // TIP 로그인 경우 process/step 정보 추가 표시
      if (log.logType === "TIP" && (log.process || log.step || log.ppid)) {
        row.info1 = `${log.eventType} (${log.process || "N/A"}/${
          log.step || "N/A"
        })`;
      }

      return row;
    })
    .sort((a, b) => b.timestamp - a.timestamp);

  return transformed;
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\utils\groupLabel.js -----

import { groupConfig } from "./timelineMeta";

export function makeGroupLabel(type, title, showLegend) {
  if (!showLegend) {
    return `<div style="width:240px">${title}</div>`;
  }
  const EMOJI = {
    RUN: "🟦RUN ",
    IDLE: "🟨IDLE ",
    PM: "🟩PM ",
    DOWN: "🟥DOWN ",
    OPEN: "🟦OPEN ",
    CLOSE: "🟥CLOSE ",
    ALARM: "🟥ALARM ",
    WARN: "🟧WARN ",
    TTM_FAIL: "🟥TTM_FAIL ",
    TTM_WARN: "🟨TTM_WARN ",
    ISSUED: "🟦ISSUED ",
    CLOSED: "🟪CLOSED ",
  };
  const config = groupConfig[type];
  if (!config) return `<div style="width:240px"></div>`;
  const legendHtml = Object.keys(config.stateColors)
    .map((state) => `<span>${EMOJI[state] || "▪️"}</span>`)
    .join(" ");
  return `<div style="width:240px;">${legendHtml}</div>`;
}

export function makeTipGroupLabel(process, step, ppid, showLegend) {
  // PPID만 표시하도록 수정
  const displayText = `<div class="tip-group-label-simple">${
    ppid || "N/A"
  }</div>`;

  if (!showLegend) {
    return `<div style="width:240px">${displayText}</div>`;
  }

  // Legend 모드일 때는 OPEN/CLOSE 범례 표시
  const legendHtml = `<span>🟦OPEN </span><span>🟥CLOSE </span>`;
  return `<div style="width:240px;">${legendHtml}</div>`;
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\utils\timelineMeta.js -----

/**
 * 각 로그 타입(logType)별 컬러 매핑
 * Tailwind 색상 클래스로 작성 (timeline.css @apply 로 색 지정)
 */
export const groupConfig = {
  EQP: {
    stateColors: {
      RUN: "bg-blue-600 border-blue-700",
      IDLE: "bg-yellow-600 border-yellow-700",
      PM: "bg-green-600 border-green-700",
      DOWN: "bg-red-600 border-red-700",
    },
  },
  TIP: {
    stateColors: {
      OPEN: "bg-blue-600 border-blue-700",
      CLOSE: "bg-red-600 border-red-700",
    },
  },
  RACB: {
    stateColors: {
      ALARM: "bg-red-600 border-red-700",
      WARN: "bg-amber-600 border-amber-700",
    },
  },
  CTTTM: {
    stateColors: {
      TTM_FAIL: "bg-red-600 border-red-700",
      TTM_WARN: "bg-yellow-600 border-yellow-700",
    },
  },
  JIRA: {
    stateColors: {
      ISSUED: "bg-blue-600 border-blue-700",
      CLOSED: "bg-purple-600 border-purple-700",
    },
  },
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\utils\timelineUtils.js -----

// src/features/timeline/utils/timelineUtils.js
import { groupConfig } from "./timelineMeta";

/** ➜ 로그 Item.id 생성 (예: RACB_LOG-2025-06-02T12:00:00.000Z) */
export const makeItemId = (group, time) => {
  const iso = new Date(time).toISOString().replace(/\.\d+Z$/, ".000Z");
  return `${group}-${iso}`;
};

/** ➜ vis-timeline 아이템 변환 */
export const processData = (logType, data, makeRangeContinuous = false) => {
  const cfg = groupConfig[logType];
  if (!cfg) return [];

  // 데이터를 eventTime 순으로 정렬
  const sortedData = data
    .filter((l) => l && l.eventTime)
    .sort((a, b) => new Date(a.eventTime) - new Date(b.eventTime));

  return sortedData.map((l, index) => {
    const start = new Date(l.eventTime);
    let end = start; // 기본값은 point 형태
    let isRange = false;

    // makeRangeContinuous가 true인 경우 range로 만들기
    if (makeRangeContinuous) {
      if (index < sortedData.length - 1) {
        // 다음 로그의 eventTime을 현재 로그의 endTime으로 설정
        end = new Date(sortedData[index + 1].eventTime);
      } else {
        // 마지막 로그인 경우, 오늘 00:00:00으로 설정
        const today = new Date(start);
        end = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate() + 1,
          0,
          0,
          0,
          0
        ); // 오늘 자정(다음날 00:00:00)
      }
      isRange = true;
    }

    const colorCls = cfg.stateColors[l.eventType] || "bg-gray-300";

    // 폰트 크기를 logType에 따라 다르게 설정
    const fontSize =
      {
        EQP: "12px",
        TIP: "11px",
        CTTTM: "10px",
        RACB: "10px",
        JIRA: "10px",
      }[logType] || "11px";

    return {
      id: l.id,
      group: logType,
      // HTML로 직접 스타일 적용
      content: `<span style="font-size: ${fontSize}; font-weight: 500;">${
        l.eventType || ""
      }</span>`,
      start,
      end,
      type: isRange ? "range" : "point",
      className: colorCls,
      title: [
        l.comment,
        l.operator ? `👤 ${l.operator}` : null,
        l.url ? `🔗 ${l.url}` : null,
      ]
        .filter(Boolean)
        .join("\n"),
    };
  });
};

/**
 * TIP 데이터를 process, step, ppid로 서브그룹화
 * @param {Array} tipData - TIP 로그 데이터
 * @returns {{groups: Array, items: Array}} - 그룹과 아이템 배열
 */
export const processTipDataWithSubgroups = (tipData) => {
  const subgroupMap = new Map();
  const items = [];

  // TIP 데이터를 그룹별로 분류하고 정렬
  const groupedData = new Map();
  tipData.forEach((log) => {
    const process = log.process || "unknown";
    const step = log.step || "unknown";
    const ppid = log.ppid || "unknown";
    const subgroupKey = `TIP_${process}_${step}_${ppid}`;

    if (!groupedData.has(subgroupKey)) {
      groupedData.set(subgroupKey, []);
    }
    groupedData.get(subgroupKey).push(log);
  });

  // 각 그룹별로 처리
  groupedData.forEach((logs, subgroupKey) => {
    const [, process, step, ppid] = subgroupKey.split("_");

    if (!subgroupMap.has(subgroupKey)) {
      subgroupMap.set(subgroupKey, {
        id: subgroupKey,
        content: `<div class="tip-subgroup-label">
          <span class="process">${process}</span>
          <span class="separator">/</span>
          <span class="step">${step}</span>
          <span class="separator">/</span>
          <span class="ppid">${ppid}</span>
        </div>`,
        className: "tip-subgroup",
        treeLevel: 2, // TIP의 하위 레벨
        showNested: false, // 기본적으로 접힌 상태
      });
    }

    // 그룹 내 로그들을 eventTime 순으로 정렬
    const sortedLogs = logs.sort(
      (a, b) => new Date(a.eventTime) - new Date(b.eventTime)
    );

    // 각 로그를 range 형태로 아이템 생성
    sortedLogs.forEach((log, index) => {
      const start = new Date(log.eventTime);
      let end = start;

      // 다음 로그가 있으면 그 시간을 end로, 없으면 오늘 자정으로 설정
      if (index < sortedLogs.length - 1) {
        end = new Date(sortedLogs[index + 1].eventTime);
      } else {
        const today = new Date(start);
        end = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate() + 1,
          0,
          0,
          0,
          0
        ); // 오늘 자정(다음날 00:00:00)
      }

      const cfg = groupConfig.TIP;
      const colorCls = cfg.stateColors[log.eventType] || "bg-gray-300";

      items.push({
        id: log.id,
        group: subgroupKey, // 서브그룹에 할당
        content: `<span style="font-size: 11px; font-weight: 500;">${
          log.eventType || ""
        }</span>`,
        start,
        end,
        type: "range", // range 형태로 변경
        className: colorCls,
        title: [
          `Process: ${process}`,
          `Step: ${step}`,
          `PPID: ${ppid}`,
          log.comment,
          log.operator ? `👤 ${log.operator}` : null,
          log.url ? `🔗 ${log.url}` : null,
        ]
          .filter(Boolean)
          .join("\n"),
        // 원본 데이터 보존 (선택 시 필요)
        originalData: log,
      });
    });
  });

  // 서브그룹을 정렬 (process -> step -> ppid 순)
  const sortedGroups = Array.from(subgroupMap.values()).sort((a, b) => {
    const [, processA, stepA, ppidA] = a.id.split("_");
    const [, processB, stepB, ppidB] = b.id.split("_");

    if (processA !== processB) return processA.localeCompare(processB);
    if (stepA !== stepB) return stepA.localeCompare(stepB);
    return ppidA.localeCompare(ppidB);
  });

  return {
    groups: sortedGroups,
    items,
  };
};

/** ±3일 버퍼 (최대 줌 아웃을 위해 버퍼 확대) */
export const addBuffer = (min, max) => {
  const B = 15 * 24 * 60 * 60 * 1000; // 15일
  return { min: new Date(min - B), max: new Date(max + B) };
};

/** 전체 로그 범위 계산 - eventTime만 사용하도록 수정 */
export const calcRange = (logs) => {
  // eventTime만 추출
  const eventTimes = logs
    .filter((l) => l && l.eventTime)
    .map((l) => new Date(l.eventTime).getTime())
    .filter((time) => !isNaN(time));

  if (!eventTimes.length) {
    const today = new Date();
    const startOfDay = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate()
    );
    const endOfDay = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate(),
      23,
      59,
      59
    );
    return { min: startOfDay, max: endOfDay };
  }

  // eventTime의 최소값과 최대값
  const minTime = Math.min(...eventTimes);
  const maxTime = Math.max(...eventTimes);

  return { min: new Date(minTime), max: new Date(maxTime) };
};


----- C:\Users\pjw75\Desktop\eqp-timeline\src\features\timeline\index.js -----

export * from "./api/timelineApi";
export * from "./hooks/useLogQueries";
export { default as TimelineBoard } from "./components/TimelineBoard";


----- C:\Users\pjw75\Desktop\eqp-timeline\src\pages\TimelinePage.jsx -----

// src/pages/TimelinePage.jsx
import React, { useState, useMemo } from "react";
import { useParams } from "react-router-dom";
import { AdjustmentsHorizontalIcon } from "@heroicons/react/24/outline";
import { useLogs } from "@/features/timeline";
import { useSelectionStore } from "@/shared/store";
import { useUrlValidation } from "@/features/timeline/hooks/useUrlValidation";
import { useUrlSync } from "@/features/timeline/hooks/useUrlSync";
import {
  groupLogsByType,
  transformLogsToTableData,
} from "@/features/timeline/utils/dataTransformers";
import { DEFAULT_TYPE_FILTERS } from "@/features/timeline/constants";
import LogViewerSection from "@/features/timeline/components/LogViewerSection";
import DataLogSection from "@/features/timeline/components/DataLogSection";
import ShareButton from "@/features/timeline/components/ShareButton";
import { TimelineBoard } from "@/features/timeline";
import LogDetailSection from "@/features/table/LogDetailSection";
import LoadingSpinner from "@/shared/LoadingSpinner";
import Drawer from "@/shared/Drawer";
import TimelineSettings from "@/features/timeline/components/TimelineSettings";

export default function TimelinePage() {
  const params = useParams();
  const {
    lineId,
    sdwtId,
    prcGroup,
    eqpId,
    setLine,
    setSdwt,
    setPrcGroup,
    setEqp,
    selectedRow,
  } = useSelectionStore();

  // URL 검증
  const { isValidating, validationError, isUrlInitialized } = useUrlValidation(
    params,
    lineId,
    eqpId,
    setLine,
    setSdwt,
    setPrcGroup,
    setEqp
  );

  // URL 동기화
  useUrlSync(lineId, eqpId, isValidating, isUrlInitialized);

  // 로그 데이터 가져오기
  const enabled = Boolean(lineId && eqpId);
  const {
    data: logs = [],
    isLoading: logsLoading,
    isError: logsError,
  } = useLogs({ lineId, eqpId }, enabled);

  // 로컬 상태
  const [typeFilters, setTypeFilters] = useState(DEFAULT_TYPE_FILTERS);
  const [showLegend, setShowLegend] = useState(false);
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [selectedTipGroups, setSelectedTipGroups] = useState(["__ALL__"]);

  // 필터 핸들러
  const handleFilter = (e) =>
    setTypeFilters((prev) => ({ ...prev, [e.target.name]: e.target.checked }));

  // 데이터 변환
  const logsByType = useMemo(() => groupLogsByType(logs), [logs]);
  const tableData = useMemo(
    () =>
      enabled && !logsLoading
        ? transformLogsToTableData(logs, typeFilters)
        : [],
    [logs, logsLoading, enabled, typeFilters]
  );

  // 선택된 로그
  const selectedLog = useMemo(
    () => logs.find((log) => String(log.id) === String(selectedRow)),
    [logs, selectedRow]
  );

  // 검증 중일 때 로딩 표시
  if (isValidating) {
    return (
      <div className="flex items-center justify-center h-[80vh]">
        <LoadingSpinner />
      </div>
    );
  }

  // 에러 처리
  if (logsError) {
    return (
      <div className="flex items-center justify-center h-[80vh]">
        <p className="text-red-500">로그 로딩 오류!</p>
      </div>
    );
  }

  // 검증 에러 표시
  if (validationError) {
    return (
      <div className="flex items-center justify-center h-[80vh]">
        <div className="text-center">
          <p className="text-red-500 mb-2">{validationError}</p>
          <p className="text-gray-500">잠시 후 메인 페이지로 이동합니다...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col lg:flex-row h-[calc(100vh-85px)] gap-2 mt-3">
      {/* 왼쪽 패널 */}
      <div className="flex flex-col h-full min-h-0 lg:w-[35%] gap-2">
        <LogViewerSection
          lineId={lineId}
          sdwtId={sdwtId}
          prcGroup={prcGroup}
          eqpId={eqpId}
          setLine={setLine}
          setSdwt={setSdwt}
          setPrcGroup={setPrcGroup}
          setEqp={setEqp}
        />

        <div className="flex-1 min-h-0 flex flex-col gap-2">
          <DataLogSection
            eqpId={eqpId}
            logsLoading={logsLoading}
            tableData={tableData}
            typeFilters={typeFilters}
            handleFilter={handleFilter}
          />

          <section
            className="bg-white dark:bg-slate-800 shadow rounded-xl p-3 flex-[1] min-h-0 flex flex-col overflow-auto"
            style={{ minHeight: 180, maxHeight: 320 }}
          >
            <h2 className="text-md font-bold text-slate-900 dark:text-white border-slate-200 dark:border-slate-700 pb-1">
              📝 Log Detail
            </h2>
            <hr className="my-1 border-slate-300 dark:border-slate-600" />
            <LogDetailSection log={selectedLog} />
          </section>
        </div>
      </div>

      {/* 오른쪽 타임라인 패널 */}
      <div className="lg:w-[65%] h-full overflow-hidden bg-white dark:bg-slate-800 shadow rounded-xl p-4">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <h2 className="text-md font-bold text-slate-900 dark:text-white">
              📊 Timeline
            </h2>
            {lineId && eqpId && <ShareButton />}
          </div>

          {/* 설정 버튼 - EQP가 선택되었을 때만 표시 */}
          {eqpId && !logsLoading && (
            <button
              onClick={() => setIsDrawerOpen(true)}
              className="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-50 dark:hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              <AdjustmentsHorizontalIcon className="h-4 w-4" />
              설정
            </button>
          )}
        </div>

        <hr className="border-slate-300 dark:border-slate-600" />

        {!eqpId && !logsLoading ? (
          <div className="flex items-center justify-center h-full">
            <p className="text-center text-slate-600 dark:text-slate-400">
              EQP를 선택하세요.
            </p>
          </div>
        ) : logsLoading ? (
          <div className="flex items-center justify-center h-full">
            <LoadingSpinner />
          </div>
        ) : (
          <div className="mt-4">
            <TimelineBoard
              dataMap={logsByType}
              showLegend={showLegend}
              selectedTipGroups={selectedTipGroups}
            />
          </div>
        )}
      </div>

      {/* Settings Drawer */}
      <Drawer
        isOpen={isDrawerOpen}
        onClose={() => setIsDrawerOpen(false)}
        title="타임라인 설정"
      >
        <TimelineSettings
          showLegend={showLegend}
          onLegendToggle={() => setShowLegend((v) => !v)}
          tipLogs={logsByType.TIP}
          selectedTipGroups={selectedTipGroups}
          onTipFilterChange={setSelectedTipGroups}
        />
      </Drawer>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\apiClient.js -----

const DEFAULT_TIMEOUT = 10000; // 10초
const MAX_RETRIES = 3;

/**
 * 개선된 API 클라이언트
 * @param {string} url - API 엔드포인트
 * @param {Object} options - 요청 옵션
 * @param {number} options.timeout - 타임아웃 (ms)
 * @param {number} options.retries - 재시도 횟수
 * @param {Object} options.params - 쿼리 파라미터
 */
export const apiClient = async (
  url,
  { params, timeout = DEFAULT_TIMEOUT, retries = MAX_RETRIES, ...opts } = {}
) => {
  // 기본 URL 유효성 검사
  const baseUrl = import.meta.env.VITE_API_BASE_URL;
  if (!baseUrl) {
    throw new Error(
      "API_BASE_URL이 설정되지 않았습니다. 환경변수를 확인해주세요."
    );
  }

  // 쿼리스트링 생성
  const qs = params ? "?" + new URLSearchParams(params) : "";
  const fullUrl = baseUrl + url + qs;

  // AbortController로 타임아웃 처리
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  const executeRequest = async (attempt = 1) => {
    try {
      const response = await fetch(fullUrl, {
        headers: {
          "Content-Type": "application/json",
          ...opts.headers,
        },
        signal: controller.signal,
        ...opts,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text();
        let errorMessage;

        // HTTP 상태 코드별 메시지
        switch (response.status) {
          case 400:
            errorMessage = "잘못된 요청입니다.";
            break;
          case 401:
            errorMessage = "인증이 필요합니다.";
            break;
          case 403:
            errorMessage = "접근 권한이 없습니다.";
            break;
          case 404:
            errorMessage = "요청한 데이터를 찾을 수 없습니다.";
            break;
          case 500:
            errorMessage = "서버 오류가 발생했습니다.";
            break;
          case 503:
            errorMessage = "서비스를 일시적으로 사용할 수 없습니다.";
            break;
          default:
            errorMessage = errorText || `HTTP ${response.status} 오류`;
        }

        const error = new Error(errorMessage);
        error.status = response.status;
        error.url = fullUrl;
        throw error;
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);

      // 타임아웃 에러 처리
      if (error.name === "AbortError") {
        throw new Error(`요청 시간이 초과되었습니다. (${timeout}ms)`);
      }

      // 네트워크 에러이고 재시도 가능한 경우
      if (attempt < retries && isRetryableError(error)) {
        console.warn(
          `API 요청 실패 (${attempt}/${retries}): ${error.message}. 재시도 중...`
        );
        await delay(Math.pow(2, attempt) * 1000); // 지수 백오프
        return executeRequest(attempt + 1);
      }

      // 마지막 에러는 그대로 throw
      throw error;
    }
  };

  return executeRequest();
};

/**
 * 재시도 가능한 에러인지 확인
 */
function isRetryableError(error) {
  // 네트워크 에러나 5xx 서버 에러는 재시도 가능
  return (
    !error.status || // 네트워크 에러
    error.status >= 500 || // 서버 에러
    error.status === 408 || // Request Timeout
    error.status === 429 // Too Many Requests
  );
}

/**
 * 지연 함수
 */
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\dateUtils.js -----

/**
 * Format a Date (or date-like value) as 'YY/MM/DD HH:mm'.
 * Returns the input unchanged if it cannot be parsed.
 *
 * @param {Date|string|number} date - value convertible to Date
 * @returns {string} formatted date string
 */
export function formatDateTime(date) {
  const d = new Date(date);
  if (Number.isNaN(d.getTime())) return date;
  const yy = String(d.getFullYear()).slice(-2);
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const mi = String(d.getMinutes()).padStart(2, "0");
  return `${yy}/${mm}/${dd} ${hh}:${mi}`;
}



----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\Drawer.jsx -----

import React from "react";
import { XMarkIcon } from "@heroicons/react/24/outline";

export default function Drawer({ isOpen, onClose, title, children }) {
  return (
    <>
      {/* 배경 오버레이 - 완전 투명 */}
      {isOpen && (
        <div className="fixed inset-0 bg-black/20 z-40" onClick={onClose} />
      )}

      {/* 드로어 패널 - navbar 아래부터 시작 */}
      <div
        className={`fixed right-0 top-[125px] h-[calc(100vh-150px)] w-80 bg-white dark:bg-slate-800 shadow-xl z-40 rounded-l-2xl transform transition-transform duration-300 ease-in-out ${
          isOpen ? "translate-x-0" : "translate-x-full"
        }`}
      >
        {/* 헤더 */}
        <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white">
            {title}
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-500 dark:hover:text-gray-300 focus:outline-none"
          >
            <XMarkIcon className="h-6 w-6" />
          </button>
        </div>

        {/* 컨텐츠 */}
        <div className="p-4 overflow-y-auto h-[calc(100%-4rem)]">
          {children}
        </div>
      </div>
    </>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\LoadingSpinner.jsx -----

export default function LoadingSpinner() {
  return (
    <div className="flex justify-center items-center" role="status">
      <div className="animate-spin rounded-full h-5 w-5 border-4 border-blue-500 border-t-transparent" />
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\Navbar.jsx -----

import React, { useState, useEffect } from "react";
import { Link } from "react-router-dom";
import {
  Dialog,
  DialogPanel,
  Disclosure,
  DisclosureButton,
  DisclosurePanel,
  Popover,
  PopoverButton,
  PopoverGroup,
  PopoverPanel,
} from "@headlessui/react";
import {
  ArrowPathIcon,
  Bars3Icon,
  ChartPieIcon,
  CursorArrowRaysIcon,
  FingerPrintIcon,
  SquaresPlusIcon,
  XMarkIcon,
  SunIcon,
  MoonIcon,
} from "@heroicons/react/24/outline";
import {
  ChevronDownIcon,
  PhoneIcon,
  PlayCircleIcon,
} from "@heroicons/react/20/solid";

// "Product" 드롭다운에 사용될 예시 데이터
const products = [
  {
    name: "Analytics",
    description: "트래픽 분석",
    href: "#",
    icon: ChartPieIcon,
  },
  {
    name: "Engagement",
    description: "고객 소통",
    href: "#",
    icon: CursorArrowRaysIcon,
  },
  {
    name: "Security",
    description: "데이터 보안",
    href: "#",
    icon: FingerPrintIcon,
  },
  {
    name: "Integrations",
    description: "외부 연동",
    href: "#",
    icon: SquaresPlusIcon,
  },
  {
    name: "Automations",
    description: "자동화",
    href: "#",
    icon: ArrowPathIcon,
  },
];
const callsToAction = [
  { name: "Watch demo", href: "#", icon: PlayCircleIcon },
  { name: "Contact sales", href: "#", icon: PhoneIcon },
];

export default function Navbar() {
  // 모바일 메뉴와 다크모드 상태를 관리
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [darkMode, setDarkMode] = useState(false);

  // 컴포넌트가 처음 마운트될 때, localStorage나 OS 기본 테마를 기준으로 다크모드 설정을 결정
  useEffect(() => {
    const isDark =
      localStorage.theme === "dark" ||
      (!("theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches);
    setDarkMode(isDark);
    if (isDark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }
  }, []);

  // 다크모드 토글 (버튼 클릭 시 실행)
  const toggleDarkMode = () => {
    // Tailwind 공식 권장 방식: classList.toggle 로 결과값을 그대로 사용
    const isDark = document.documentElement.classList.toggle("dark");
    setDarkMode(isDark);

    // 사용자가 '라이트' 모드를 선택한 경우 key 자체를 지워 두면
    // 다음 방문 시 OS 선호도(prefers-color-scheme)가 다시 적용됩니다.
    if (isDark) {
      localStorage.theme = "dark";
    } else {
      localStorage.removeItem("theme");
    }
  };

  return (
    // 상단 고정 네비게이션 바
    <header className="bg-white dark:bg-gray-800 shadow-md sticky top-0 z-50  h-15">
      <nav
        aria-label="Global"
        className="mx-auto flex max-w-7xl items-center justify-between p-5 lg:px-8 h-15"
      >
        {/* 로고: 메인 페이지로 이동 */}
        <div className="flex lg:flex-1">
          <Link to="/" className="-m-1.5 p-1.5">
            <span className="sr-only">Your Company</span>
            <img
              alt="Company Logo"
              src="https://tailwindcss.com/plus-assets/img/logos/158x48/transistor-logo-gray-900.svg"
              className="h-8 w-auto"
            />
          </Link>
        </div>
        {/* 모바일 메뉴 버튼 (작은 화면에서만 보임) */}
        <div className="flex lg:hidden">
          <button
            type="button"
            onClick={() => setMobileMenuOpen(true)}
            className="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700 dark:text-gray-300"
          >
            <span className="sr-only">Open main menu</span>
            <Bars3Icon aria-hidden="true" className="size-6" />
          </button>
        </div>
        {/* 데스크탑 메뉴: Product, Timeline 등 네비게이션 */}
        <PopoverGroup className="hidden lg:flex lg:gap-x-12">
          <Popover className="relative">
            <PopoverButton className="flex items-center gap-x-1 text-xs/6 font-semibold text-gray-900 dark:text-gray-100 focus:outline-none">
              Product
              <ChevronDownIcon
                aria-hidden="true"
                className="size-5 flex-none text-gray-400 dark:text-gray-500"
              />
            </PopoverButton>
            {/* Product 드롭다운 패널 */}
            <PopoverPanel
              transition
              className="absolute top-full -left-8 z-20 mt-3 w-screen max-w-md overflow-hidden rounded-3xl bg-white dark:bg-gray-800 shadow-lg ring-1 ring-gray-900/5 dark:ring-white/10 transition"
            >
              <div className="p-4">
                {products.map((item) => (
                  <div
                    key={item.name}
                    className="group relative flex items-center gap-x-6 rounded-lg p-4 text-xs/6 hover:bg-gray-50 dark:hover:bg-gray-700"
                  >
                    <div className="flex size-11 flex-none items-center justify-center rounded-lg bg-gray-50 dark:bg-gray-700 group-hover:bg-white dark:group-hover:bg-gray-600">
                      <item.icon
                        aria-hidden="true"
                        className="size-6 text-gray-600 dark:text-gray-400 group-hover:text-indigo-600 dark:group-hover:text-indigo-400"
                      />
                    </div>
                    <div className="flex-auto">
                      <a
                        href={item.href}
                        className="block font-semibold text-gray-900 dark:text-gray-100"
                      >
                        {item.name}
                        <span className="absolute inset-0" />
                      </a>
                      <p className="mt-1 text-gray-600 dark:text-gray-400">
                        {item.description}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
              {/* 하단 액션 버튼 */}
              <div className="grid grid-cols-2 divide-x divide-gray-900/5 dark:divide-white/10 bg-gray-50 dark:bg-gray-700/50">
                {callsToAction.map((item) => (
                  <a
                    key={item.name}
                    href={item.href}
                    className="flex items-center justify-center gap-x-2.5 p-3 text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-600"
                  >
                    <item.icon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500"
                    />
                    {item.name}
                  </a>
                ))}
              </div>
            </PopoverPanel>
          </Popover>
          {/* 타임라인 페이지로 이동하는 메뉴 */}
          <Link
            to="/timeline"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Timeline
          </Link>
          <Link
            to="/apps"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Apps
          </Link>
          <a
            href="#"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Company
          </a>
        </PopoverGroup>
        {/* 데스크탑: 다크모드 토글 + 로그인 */}
        <div className="hidden lg:flex lg:flex-1 lg:items-center lg:justify-end lg:gap-x-6">
          <button
            onClick={toggleDarkMode}
            className="p-2 rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none"
            aria-label="Toggle dark mode"
          >
            {darkMode ? (
              <SunIcon className="size-5" />
            ) : (
              <MoonIcon className="size-5" />
            )}
          </button>
          <a
            href="#"
            className="text-xs/6 font-semibold text-gray-900 dark:text-gray-100 hover:text-indigo-600 dark:hover:text-indigo-400"
          >
            Log in <span aria-hidden="true">&rarr;</span>
          </a>
        </div>
      </nav>
      {/* 모바일 메뉴 다이얼로그: 작은 화면에서만 열림 */}
      <Dialog
        open={mobileMenuOpen}
        onClose={setMobileMenuOpen}
        className="lg:hidden"
      >
        <div className="fixed inset-0 z-20" />
        <DialogPanel className="fixed inset-y-0 right-0 z-30 w-full overflow-y-auto bg-white dark:bg-gray-800 px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10 dark:sm:ring-white/10">
          <div className="flex items-center justify-between">
            <Link
              to="/"
              className="-m-1.5 p-1.5"
              onClick={() => setMobileMenuOpen(false)}
            >
              <span className="sr-only">Your Company</span>
              <img
                alt="Company Logo"
                src="https://tailwindcss.com/img/logos/mark.svg?color=indigo&shade=600"
                className="h-8 w-auto"
              />
            </Link>
            <button
              type="button"
              onClick={() => setMobileMenuOpen(false)}
              className="-m-2.5 rounded-md p-2.5 text-gray-700 dark:text-gray-300"
            >
              <span className="sr-only">Close menu</span>
              <XMarkIcon aria-hidden="true" className="size-6" />
            </button>
          </div>
          <div className="mt-6 flow-root">
            <div className="-my-6 divide-y divide-gray-500/10 dark:divide-gray-700">
              <div className="space-y-2 py-6">
                {/* Product 드롭다운 (모바일) */}
                <Disclosure as="div" className="-mx-3">
                  <DisclosureButton className="group flex w-full items-center justify-between rounded-lg py-2 pr-3.5 pl-3 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700">
                    Product
                    <ChevronDownIcon
                      aria-hidden="true"
                      className="size-5 flex-none text-gray-400 dark:text-gray-500 group-data-open:rotate-180"
                    />
                  </DisclosureButton>
                  <DisclosurePanel className="mt-2 space-y-2">
                    {[...products, ...callsToAction].map((item) => (
                      <DisclosureButton
                        key={item.name}
                        as="a"
                        href={item.href}
                        onClick={() => setMobileMenuOpen(false)}
                        className="block rounded-lg py-2 pr-3 pl-6 text-sm/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                      >
                        {item.name}
                      </DisclosureButton>
                    ))}
                  </DisclosurePanel>
                </Disclosure>
                {/* 주요 메뉴들 */}
                <Link
                  to="/timeline"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Timeline
                </Link>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Marketplace
                </a>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Company
                </a>
              </div>
              <div className="py-6">
                {/* 다크모드 토글 (모바일) */}
                <button
                  onClick={() => {
                    toggleDarkMode();
                    setMobileMenuOpen(false);
                  }}
                  className="-mx-3 flex items-center gap-x-2 w-full rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                  aria-label="Toggle dark mode"
                >
                  {darkMode ? (
                    <SunIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  ) : (
                    <MoonIcon className="size-5 flex-none text-gray-400 dark:text-gray-500" />
                  )}
                  {darkMode ? "라이트 모드" : "다크 모드"}
                </button>
                <a
                  href="#"
                  onClick={() => setMobileMenuOpen(false)}
                  className="-mx-3 block rounded-lg px-3 py-2.5 text-base/7 font-semibold text-gray-900 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700"
                >
                  Log in
                </a>
              </div>
            </div>
          </div>
        </DialogPanel>
      </Dialog>
    </header>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\shared\store.js -----

import { create } from "zustand";

export const useSelectionStore = create((set) => ({
  /* —— A. 테이블·타임라인 동기 선택 —— */
  selectedRow: null,
  source: null,
  setSelectedRow: (row, src) => set({ selectedRow: row, source: src }),

  /* —— B. 드릴다운 상태 —— */
  lineId: "",
  sdwtId: "",
  prcGroup: "", // PRC Group 추가
  eqpId: "",
  setLine: (id) => set({ lineId: id, sdwtId: "", prcGroup: "", eqpId: "" }),
  setSdwt: (id) => set({ sdwtId: id, prcGroup: "", eqpId: "" }),
  setPrcGroup: (id) => set({ prcGroup: id, eqpId: "" }), // PRC Group setter 추가
  setEqp: (id) => set({ eqpId: id }),

  /* —— C. vis-timeline 인스턴스 풀 —— */
  pool: [],
  register: (tl) => set((s) => ({ pool: [...s.pool, tl] })),
  unregister: (tl) => set((s) => ({ pool: s.pool.filter((t) => t !== tl) })),

  syncRange: (self, start, end) =>
    set((state) => {
      state.pool.forEach((tl) => {
        if (tl !== self) tl.setWindow(start, end, { animation: false });
      });
      return state;
    }),
}));


----- C:\Users\pjw75\Desktop\eqp-timeline\src\styles\timeline.css -----

/* ─────────────────────────────────────────────────────────────────────────
   vis-timeline 커스터마이징
───────────────────────────────────────────────────────────────────────── */

.timeline-container { margin-bottom: 16px; }

/* 공통 아이템 */
.vis-item {
  @apply border border-transparent text-slate-800;
  border-radius: 0 !important;
  margin-right: -1px;
  box-shadow: none !important;
  pointer-events: all !important;
}
.dark .vis-item { @apply text-slate-100; }

/* 아이템 내부 content 텍스트 스타일 */
.vis-item .vis-item-content {
  font-size: 11px !important;  /* 폰트 크기 조절 */
  font-weight: 500 !important;  /* 약간 굵게 */
  padding: 2px 4px !important;  /* 내부 여백 */
  white-space: nowrap !important;  /* 줄바꿈 방지 */
  overflow: hidden !important;
  text-overflow: ellipsis !important;  /* 긴 텍스트는 ... 처리 */
}

/* 상태 색상 */
.vis-item.bg-red-500    { @apply bg-red-500 border-red-600; }
.vis-item.bg-green-500  { @apply bg-green-500 border-green-600; }
.vis-item.bg-blue-500   { @apply bg-blue-500 border-blue-600; }
.vis-item.bg-yellow-500 { @apply bg-yellow-500 border-yellow-600; }
.vis-item.bg-gray-300   { @apply bg-gray-300 border-gray-400; }
/* 600 계열 */
.vis-item.bg-red-600    { @apply bg-red-600  border-red-700; }
.vis-item.bg-blue-600   { @apply bg-blue-600 border-blue-700; }
.vis-item.bg-yellow-600 { @apply bg-yellow-600 border-yellow-700; }
.vis-item.bg-green-600  { @apply bg-green-600 border-green-700; }
.vis-item.bg-amber-600  { @apply bg-amber-600 border-amber-700; }
.vis-item.bg-purple-600 { @apply bg-purple-600 border-purple-700; }
.vis-item.bg-gray-600   { @apply bg-gray-600 border-gray-700; }
.vis-item.bg-orange-600 { @apply bg-orange-600 border-orange-700; }

/* 선택 아이템 */
.vis-item.vis-selected {
  outline: 2px dashed #fb923c !important;  
  outline-offset: -2px !important;              
  background-color: rgba(251, 146, 60, 0.2) !important; 
  filter: brightness(1.1) !important;
  z-index: 10 !important;
}

/* 레인지/포인트 */
.vis-item.vis-range { pointer-events: all !important; min-height: 20px !important; }
.vis-item.vis-point { pointer-events: all !important; }

/* 시간축 텍스트 */
.vis-time-axis .vis-text,
.vis-time-axis .vis-label { font-size: 12px !important; color: #334155; }
.dark .vis-time-axis .vis-text,
.dark .vis-time-axis .vis-label { color: #f1f5f9 !important; }

/* 그룹 라벨 */
.vis-label.custom-group-label { color: #334155; font-size: 12px !important;}
.dark .vis-label.custom-group-label { color: #f1f5f9 !important; font-size: 12px !important; }

/* 테이블 스크롤바 */
.table-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
.table-scroll::-webkit-scrollbar-track { background: #ffffff; border-radius: 10px; }
.table-scroll::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; border: 1px solid #e2e8f0; }
.dark .table-scroll::-webkit-scrollbar-track { background: #1e293b; }
.dark .table-scroll::-webkit-scrollbar-thumb { background: #475569; border: 1px solid #1e293b; }
.dark .table-scroll::-webkit-scrollbar-thumb:hover { background: #64748b; }

/* react-window 스크롤바 스타일 */
.scrollbar-thin {
  scrollbar-width: thin;
  scrollbar-color: #94a3b8 #f1f5f9;
}

.dark .scrollbar-thin {
  scrollbar-color: #475569 #1e293b;
}

/* 웹킷 브라우저용 스크롤바 */
.scrollbar-thin::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.scrollbar-thin::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
  background: #94a3b8;
  border-radius: 4px;
}

.scrollbar-thin::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

.dark .scrollbar-thin::-webkit-scrollbar-track {
  background: #1e293b;
}

.dark .scrollbar-thin::-webkit-scrollbar-thumb {
  background: #475569;
}

.dark .scrollbar-thin::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

/* 그룹 라벨 고정 폭 */
.vis-label.custom-group-label {
  width: 150px !important;
  min-width: 150px !important;
  max-width: 150px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 그룹 라벨에 legend-mode 클래스가 추가됐을 때만 폰트 크기를 10px로 */
.vis-label.legend-mode {
  font-size: 12px !important;
  font-weight: normal !important;
  letter-spacing: 0 !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 240px !important;
  min-width: 240px !important;
  max-width: 240px !important;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 !important;
}

/* 가상 스크롤 최적화 */
.scrollbar-thin {
  scrollbar-width: thin;
  scrollbar-color: #94a3b8 #f1f5f9;
  /* 하드웨어 가속 */
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}

/* 간단한 TIP 그룹 라벨 (PPID만 표시) */
.tip-group-label-simple {
  font-size: 12px;
  font-weight: 600;
  color: #3b82f6;
  text-align: center;
}

.dark .tip-group-label-simple {
  color: #60a5fa;
}

/* TIP 그룹 스타일 */
.vis-label.tip-group {
  background-color: rgba(59, 130, 246, 0.05);
  border-left: 3px solid #3b82f6;
}

.dark .vis-label.tip-group {
  background-color: rgba(59, 130, 246, 0.1);
}

/* TIP 그룹 hover 효과 */
.vis-label.tip-group:hover {
  background-color: rgba(59, 130, 246, 0.15);
}

.dark .vis-label.tip-group:hover {
  background-color: rgba(59, 130, 246, 0.25);
}

/* 툴팁 스타일 개선 */
.vis-tooltip {
  background-color: rgba(0, 0, 0, 0.9) !important;
  color: white !important;
  font-size: 11px !important;
  padding: 8px 12px !important;
  border-radius: 6px !important;
  white-space: nowrap !important;
}

----- C:\Users\pjw75\Desktop\eqp-timeline\src\App.jsx -----

import React, { Suspense, lazy } from "react";
import { Routes, Route, Link } from "react-router-dom";
import Navbar from "@/shared/Navbar";
import LoadingSpinner from "@/shared/LoadingSpinner";

const TimelinePage = lazy(() => import("@/pages/TimelinePage"));
const AppsPage = lazy(() => import("@/pages/AppsPage"));

const HomePage = () => (
  <div className="p-6 text-center">
    <h1 className="text-2xl font-bold">홈페이지 🎉</h1>
    <p>
      상단의{" "}
      <Link className="text-indigo-600" to="/timeline">
        Timeline
      </Link>{" "}
      메뉴를 눌러 EQP 로그를 확인하세요.
    </p>
  </div>
);

export default function App() {
  return (
    <div className="h-screen flex flex-col overflow-hidden">
      <Navbar />
      <div className="flex-1 overflow-hidden px-4">
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route
            path="/timeline"
            element={
              <Suspense
                fallback={
                  <div className="flex items-center justify-center h-[80vh]">
                    <LoadingSpinner />
                  </div>
                }
              >
                <TimelinePage />
              </Suspense>
            }
          />
          {/* URL 파라미터를 통한 직접 접근 라우트 - sdwtId 제거 */}
          <Route
            path="/timeline/:lineId/:eqpId"
            element={
              <Suspense
                fallback={
                  <div className="flex items-center justify-center h-[80vh]">
                    <LoadingSpinner />
                  </div>
                }
              >
                <TimelinePage />
              </Suspense>
            }
          />
          <Route path="/apps" element={<AppsPage />} />
        </Routes>
      </div>
    </div>
  );
}


----- C:\Users\pjw75\Desktop\eqp-timeline\src\index.css -----

@import "tailwindcss";

/* === vis-timeline 공통 스타일 === */
@custom-variant dark (&:where(.dark, .dark *));
@import "./styles/timeline.css";

----- C:\Users\pjw75\Desktop\eqp-timeline\src\main.jsx -----

import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import App from "@/App";
import "@/index.css";

const qc = new QueryClient();

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <QueryClientProvider client={qc}>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </QueryClientProvider>
  </StrictMode>
);


----- C:\Users\pjw75\Desktop\eqp-timeline\eslint.config.js -----

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


----- C:\Users\pjw75\Desktop\eqp-timeline\index.html -----

<!doctype html>
<html lang="en" class="bg-slate-50 dark:bg-slate-900">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EQP Timeline Viewer</title>
    <script>
      // 다크모드 초기화
      if (
        localStorage.theme === 'dark' ||
        (!localStorage.getItem('theme') &&
          window.matchMedia('(prefers-color-scheme: dark)').matches)
      ) {
        document.documentElement.classList.add('dark');
      }
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>


----- C:\Users\pjw75\Desktop\eqp-timeline\tailwind.config.js -----

/** @type {import('tailwindcss').Config} */
import forms from "@tailwindcss/forms";

export default {
  darkMode: "class", // 버튼으로 다크모드 토글
  content: [
    "./index.html",
    "./src/**/*.{js,jsx}", // 템플릿 경로 (필수)
  ],
  theme: { extend: {} },
  plugins: [forms],

  keyframes: {
    fadeIn: {
      "0%": { opacity: "0", transform: "translateY(10px)" },
      "100%": { opacity: "1", transform: "translateY(0)" },
    },
  },
  animation: {
    "fade-in": "fadeIn 0.3s ease-out",
  },
};


----- C:\Users\pjw75\Desktop\eqp-timeline\vite.config.js -----

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite"; // ✅ v4용 Vite 플러그인
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  plugins: [
    react({
      // 선택) React Fast-Refresh & props-on-export 경고 제어 등
    }),
    tailwindcss(), // ← PostCSS도 자동 연결
  ],

  resolve: {
    // '@/foo' → 'src/foo'
    alias: { "@": path.resolve(__dirname, "src") },
  },

  server: {
    host: "0.0.0.0", // LAN 공유 필요 없으면 지워도 무방
    port: 5173, // 기본값 5173, 충돌 시 변경
  },

  // 선택) 환경변수 프리픽스 늘리기
  envPrefix: ["VITE_", "PUBLIC_"],

  // 선택) 빌드 출력 경로·크기 경고
  build: {
    outDir: "dist",
    chunkSizeWarningLimit: 800,
  },
});

